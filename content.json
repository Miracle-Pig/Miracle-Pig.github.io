{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"Repositories","date":"2022-05-16T12:27:02.457Z","updated":"2022-05-16T12:27:02.457Z","comments":false,"path":"repository/index.html","permalink":"http://example.com/repository/index.html","excerpt":"","text":"Your Repositories (github.com)"}],"posts":[{"title":"C&C++ Notebook","slug":"C&C++ Notebool","date":"2022-05-16T13:18:43.719Z","updated":"2022-05-16T13:20:26.064Z","comments":true,"path":"2022/05/16/C&C++ Notebool/","link":"","permalink":"http://example.com/2022/05/16/C&C++%20Notebool/","excerpt":"","text":"[toc] 语法宏定义的使用 以下使用方法可节约大量代码量 123#define XX()#undef XXlambda表达式 语法： 捕捉列表mutable—&gt;返回值类型{ 函数体 } [捕捉列表]：该列表总是出现在lambda表达式的起始位置，编译器根据[]来判断接下来的代码是否为lambda表达式，捕捉列表能够捕捉当前作用域中的变量，供lambda函数使用。 [val]：表示以传值方式捕捉变量val [&#x3D;]：表示以传值方式捕捉当前作用域中的变量，包括this指针。 [&amp;val]：表示以引用方式传递捕捉变量val。 [&amp;]：表示以引用方式传递捕捉当前作用域中的所有变量，包括this指针。 [this]：表示以传值方式捕捉当前的this指针。 (参数)：参数列表。与普通函数参数列表使用相同。如果不需要传递参数，可以连同”()”一起省略。 mutable：默认情况下，lambda函数总是一个const函数，捕捉的传值参数具有常性，mutable可以取消常性。使用mutable修饰符时，参数列表不能省略，即使参数为空。 —&gt;返回值类型：返回值类型。使用追踪返回类型形式声明函数的返回值类型，没有返回值此部分可省略。返回值类型明确的情况下，也可省略，由编译器推导。 {函数体}：在函数体内除了可以使用参数外，还能使用捕捉的变量。 左值与右值 概念：最简单判断左值、右值的方式是：等号左边的值即左值，等号右边的值即右值 能够取地址的，有名字的就是左值 不能取地址，没有名字的就是右值 右值引用 1T &amp;&amp;a = ReturnRvalue() 除了作为返回值，作为参数也是可以的 右值引用无论作为参数还是返回值，都可以使用临时变量，并且由于其可以窃取临时变量中的内存，导致其效率较高 常量左值引用是万能类型，当参数是常量左值时，我们传入右值也可以；当返回值是右值时，使用常量左值也可以接收。 左值引用无论是作为参数还是返回值，都要求其不能使用临时变量。 当右值引用作为构造函数参数时，这就是所谓的移动构造函数，也就是所谓的移动语义。 移动语义 让函数中的返回的临时对象空间可以不析构，可以重用 移动构造函数 123A(A &amp;&amp; a):b(a.b)&#123; a.b=nullptr;&#125; 与拷贝构造函数不同的是，它接收的是一个右值引用的参数 移动构造函数使用参数a的成员b初始化了本对象的成员b(而不是像构造函数一样需要分配内存，然后再将内容一次拷贝到新分配的内存中)，而a的成员b随后就被置空。 移动构造函数中要避免使用const右值引用 移动语义可以实现高效的swap函数，如下：、 12345678template&lt;class T&gt;void swap(T&amp; a,T&amp; b)&#123; T tmp(move(a)); a = move(b); b = move(tmp); &#125; 上述代码完全避免了资源的释放与申请，从而完成高效置换。 关键字externthread_local 功能：C++11新引入的一种存储类型，会影响变量的存储周期 C++的四种存储周期 automatic static dynamic thread 有且只有thread_local关键字修饰的变量具有线程周期(thread duration) 这些变量(或者说对象）在线程开始的时候被生成，在线程结束的时候被销毁 每一个线程都拥有一个独立的变量实例 可以和static 与 extern关键字联合使用，这将影响变量的链接属性(to adjust linkage)。 哪些变量可以被声明为thread_local？以下3类都是ok的 命名空间下的全局变量 类的static成员变量 本地变量 volatile 功能：每次存储或读取这个变量的时候，都会直接从内存中读取数据，防止编译器可能优化读取和存储，可能暂时使用寄存器中的值，如果这个变量由别的程序更新了的话，将出现不一致的现象易变性 标准库algorithm lower_bound lower_bound的讲解 前提是有序的情况下，lower_bound返回指向第一个值不小于val的位置，也就是返回第一个大于等于val值的位置。（通过二分查找） functional std::function 概述：通用多态函数封装器，存储、复制及调用任何可调用函数、lambda表达式、bind表达式或其他函数对象，还有指向成员函数指针和指向数据成员指针。若 std::function 不含目标，则称它为空。调用空std::function的目标导致抛出std::bad_function_call异常。 模板声明如下： 构造函数支持默认构造（空function，不是一个有效的function）、引用类型、右值引用、拷贝赋值运算符支持的类型也很全。 重载了bool()可以用于判断function是否是有效的 支持交互function 重载了()，支持不定参数 std::bind 概述：bind是一个标准库函数，定义在functional头文件中。可以将bind函数看作一个通用的函数适配器，它接受一个可调用对象，生成新的可调用对象来适应原对象的参数列表。 使用：auto newCallable&#x3D;bind(callable,arg_list); newCallable和callable都是可调用对象，arg_list对应calllable的参数。当我们调用newCallable时，newCallable会调用callable，并传递给它arg_list中的参数 arg_list中的参数可能包含形如_n的占位符，如_1,_2，代表了newCallable中相应位置的参数当我们调用check6(str)的时候，实际会调用check_size(str,6) auto check6&#x3D;bind(check_size,_1,6); 作用： 改变参数个数 bind可以用于改变参数的个数（减少？），如原本check_size要传入两个参数，通过bind我们可以只传入一个参数，另外的参数则在bind时决定。 改变参数位置 bind还可用于改变参数位置，例如，有一个函数bool isGreater(int a,int b)用于判断第一个参数是否大于第二个参数，则auto isSmaller&#x3D;bind(isGreater,_2,_1); 通过改变参数顺序，让bind返回的可调用对象具有相反的含义。isSmaller(1,2)将实际调用isGreater(2,1)，返回true。 设置类成员函数为回调函数 回调函数往往通过函数指针来实现，而类的成员函数，多了一个隐含的参数this，所以直接赋值给函数指针会引起编译报错。通过bind可以解决此问题 memory std::enable_shared_from_this 功能：能让其一个对象（假设其名为t，且已被一个std::shared_ptr对象pt管理）安全地生成其他额外地std::shared_ptr实例（假设名为 pt1, pt2, … ） ，它们与 pt 共享对象 t 的所有权。 用法：若一个类 T 继承 std::enable_shared_from_this ，则会为该类 T 提供成员函数： shared_from_this 。 当 T 类型对象 t 被一个为名为 pt 的 std::shared_ptr 类对象管理时，调用 T::shared_from_this 成员函数，将会返回一个新的 std::shared_ptr 对象，它与 pt 共享 t 的所有权。 为什么使用？ 需要在类对象的内部中获得一个指向当前对象的 shared_ptr 对象。 如果在一个程序中，对象内存的生命周期全部由智能指针来管理。在这种情况下，要在一个类的成员函数中，对外部返回this指针就成了一个很棘手的问题。 使用场景： 当一个类被share_ptr管理，且在类的成员函数里需要把当前类对象作为参数传给其他函数时，这时就需要传递一个指向自身的 share_ptr。 PS： 一般来说，我们不能直接将this指针返回。如果函数将this指针返回到外部某个变量保存，然后这个对象自身已经析构了，但外部变量并不知道，此时如果外部变量再使用这个指针，就会使得程序崩溃。 链接： C++11中enable_shared_from_this的用法解析 std::unique_ptr p 功能：独占资源所有权的指针 简单说，当我们独占资源的所有权的时候，可以使用 std::unique_ptr 对资源进行管理——离开 unique_ptr 对象的作用域时，会自动释放资源。这是很基本的RAII思想。 这个智能指针将拷贝构造函数和赋值运算符重载函数写在了私有下，相当于禁止了拷贝和赋值的操作，也被成为最简单的智能指针。 用法： 成员方法： 为什么使用？ 使用场景 PS 链接 std::shared_ptr p 功能：共享资源所有权的指针 采用的是引用计数原理来实现多个shared_ptr对象之间共享资源： 能够保证共享的资源只会被释放一次 用法 shared_ptr在内部会维护着一份引用计数，用来记录该份资源被几个对象共享。 当一个shared_ptr对象被销毁时（调用析构函数），析构函数内就会将该计数减1。 如果引用计数减为0后，则表示自己是最后一个使用该资源的shared_ptr对象，必须释放资源。 如果引用计数不是0，就说明自己还有其他对象在使用，则不能释放该资源，否则其他对象就成为野指针。 成员方法： 分离关联的原始指针 p.reset():它将引用计数减少1，如果引用计数变为0，则删除指针。 p.use_count(): 返回智能指针对象的引用计数。 实现 因为_ptrcount指向的对象是在堆上，因此所有的线程都能够访问到该资源，多线程在修改_ptrcount时，则会出现线程安全问题，因此需要在修改_prtcount时需要用锁来保证其数据的正确性。 “*”会返回ptr指向的对象，为什么不需要锁对其进行保护？因为ptr返回的对象有可能被读或者被写，这个不是指针内部所考虑的，而是由调用者进行考虑的。 为什么使用？ 使用场景 PS shared_ptr的循环引用 shared_ptr固然好用，但是它也会有问题存在。假设我们要使用定义一个双向链表，如果我们想要让创建出来的链表的节点都定义成shared_ptr智能指针，那么也需要将节点内的_pre和_next都定义成shared_ptr的智能指针。如果定义成普通指针，那么就不能赋值给shared_ptr的智能指针。 链接 智能指针详细解析 std::weak_ptr p 功能：独占资源所有权的指针 weak_ptr对象指向shared_ptr对象时，不会增加shared_ptr中的引用计数 用法： 成员方法： 为什么使用？ 解决循环引用 在定义双向链表或者在二叉树等有多个指针的时候,如果想要将该类型定义成智能指针，那么结构体内的指针需要定义成weak_ptr类型的指针，防止循环引用的出现。· 使用场景 PS 链接 move.h std::foward 功能：用于完美转发的，它会将输入的参数原封不动地传递到下一个函数中 完美转发： 12template&lt;typename T&gt;void IamForwording(T t)&#123; IrunCodeActually(t); &#125; 换一句话说，假定IrunCodeActuall有重载左值有右值版本，那么IamForwording传左值就进入IrunCodeActuall左值版本，传右值就进入IrunCodeActuall右值版本 std::move 功能：将左值强行转换为右值 转化的左值生命周期并没有因这种转换而改变， 用法： 确保使用std::move用于移动语义的变量是一个临时量 1234567891011121314Class Moveable&#123;public: ... Moveable(Moveable &amp;&amp;m) : i(m.i) ,h(move(m.h))&#123; //#1 m.i = nullptr; &#125; int *i;HugeMem h;&#125;Moveable a;Moveable b(a);//错误，a不是临时变量Moveable c(GetTemp()); 移动语义与std::move结合时，要格外注意不要误用，下面是一个错误使用的示例： 1234567int main()&#123; Moveable a; Moveable c(move(a)); cout &lt;&lt; *a.i &lt;&lt; endl; return 0;&#125; a本身是一个左值，但是被move强转为右值，但是a的生命周期又还没有结束，根据上述移动语义的说明，我们可知：a指向i的内存已经被c窃取了，a.i指针指向空，那么一旦输出i的值，那么程序就会出现错误。所以：我们在使用move语义时，一定要确保被强转的左值很快会被析构，否则就会带来隐患。 链接： 右值引用详解 stat.h 相关链接：(29条消息) C语言stat()函数：获取文件状态_道al的博客-CSDN博客_c stat struct stat：文件状态结构体 string.h memchr C 库函数 void *memchr(const void *str, int c, size_t n) 在参数 str 所指向的字符串的前 n 个字节中搜索第一次出现字符 c（一个无符号字符）的位置。 time.h localtime（不可重入函数，非线程安全） &amp; localtime_r（可重入函数，线程安全） 功能：将日历时间转换为断点表示 用法： 123456struct tm tm;time_t time = event-&gt;getTime();localtime_r(&amp;time, &amp;tm);char buf[64];//数将时间格式化为我们想要的格式strftime(buf, sizeof(buf), m_format.c_str(), &amp;tm); 硬件级别 __builtin_expect 将流水线引入cpu，可以提高cpu的效率。更简单的说，让cpu可以预先取出下一条指令，减少cpu等待取指令的耗时，从而可以提供cpu的效率。 如果存在跳转指令，那么预先取出的指令就无用了。cpu在执行当前指令时，从内存中取出了当前指令的下一条指令。执行完当前指令后，cpu发现不是要执行下一条指令,而是执行offset偏移处的指令。cpu只能重新从内存中取出offset偏移处的指令。因此，跳转指令会降低流水线的效率，也就是降低cpu的效率。 在写程序时应该尽量避免跳转语句。那么如何避免跳转语句呢？答案就是使用__builtin_expect。 编译与调试名词解释字面值- 字面值是指在程序中无需变量保存，可直接表示为一个具体的数字或字符串的值。比如在a = b * 2这个语句中，2就是一个字面值，它本身就是一个具体的值 回调函数- 回调函数就是一个被作为参数传递的函数。 RAII思想 资源获取就是初始化 提供了一种资源自动管理的方式 当产生异常、回滚等现象时，RAII可以正确地释放掉资源 在资源的获取到释放之间，我们往往需要使用资源，但常常一些不可预计的异常是在使用过程中产生，就会使资源的释放环节没有得到执行。 RAII的实现原理很简单，利用stack上的临时对象生命期是程序自动管理的这一特点，将我们的资源释放操作封装在一个临时对象中。 它免除了对需要谨慎使用资源时而产生的大量维护代码。在保证资源正确处理的情况下，还使得代码的可读性也提高了不少。 PS词条结构 功能 用法 为什么使用？ 使用场景 PS 链接","categories":[{"name":"语言","slug":"语言","permalink":"http://example.com/categories/%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"C++ 高性能服务器框架","slug":"C++ 高性能服务器框架开发日志","date":"2022-05-16T13:10:12.678Z","updated":"2022-05-16T13:13:13.898Z","comments":true,"path":"2022/05/16/C++ 高性能服务器框架开发日志/","link":"","permalink":"http://example.com/2022/05/16/C++%20%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/","excerpt":"","text":"[toc] 概述 C++ 高性能服务器框架（High Performance Server&#x2F;HPS） 可作为WEB、数据库、游戏等服务器 框架提供基本的线程、协程库，IO库，TCP、HTTP网络应用接口 日志模块概述 功能：向文件或者控制台输出服务器日志信息 组件 日志等级（LogLevel） unknow、debug、info、warn、error、fatal 6个级别，报告服务器的各种类型的日志信息 日志事件（LogEvent） 成员属性：包含输出每个日志项的所有属性，如下： 日志级别 文件名 文件行号 程序启动依赖的耗时 线程id 协程id 日志时间 线程名称 日志格式器（LogFormatter） 功能：使用log4j格式，对输入的格式字符串进行解析 默认格式 “%d","categories":[{"name":"项目","slug":"项目","permalink":"http://example.com/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"project","slug":"project","permalink":"http://example.com/tags/project/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-05-16T09:03:24.813Z","updated":"2022-05-16T09:03:24.813Z","comments":true,"path":"2022/05/16/hello-world/","link":"","permalink":"http://example.com/2022/05/16/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"语言","slug":"语言","permalink":"http://example.com/categories/%E8%AF%AD%E8%A8%80/"},{"name":"项目","slug":"项目","permalink":"http://example.com/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"project","slug":"project","permalink":"http://example.com/tags/project/"}]}