<!DOCTYPE html>
<html lang=en>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>C++ 高性能服务器框架日志 | Hexo</title>
  <meta name="description" content="概述 C++ 高性能服务器框架（High Performance Server&#x2F;HPS） 可作为WEB、数据库、游戏等服务器 框架提供基本的线程、协程库，IO库，TCP、HTTP网络应用接口  日志模块概述 功能：向文件或者控制台输出服务器日志信息  组件 日志等级（LogLevel） unknow、debug、info、warn、error、fatal 6个级别，报告服务器的各种类型的">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ 高性能服务器框架日志">
<meta property="og:url" content="http://example.com/2022/05/16/C++%20%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="概述 C++ 高性能服务器框架（High Performance Server&#x2F;HPS） 可作为WEB、数据库、游戏等服务器 框架提供基本的线程、协程库，IO库，TCP、HTTP网络应用接口  日志模块概述 功能：向文件或者控制台输出服务器日志信息  组件 日志等级（LogLevel） unknow、debug、info、warn、error、fatal 6个级别，报告服务器的各种类型的">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://pica.zhimg.com/80/v2-be49bb55a09595a9ca8653ba5f8f3b14_720w.jpg?source=1940ef5c">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-adf545de491e45398a0e4b5fb1ec4a98_720w.jpg?source=1940ef5c">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20191025215514941.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FybWxpbnV4d3c=,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20191025220418729.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FybWxpbnV4d3c=,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20191025220607592.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FybWxpbnV4d3c=,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwolcxS62c1ZRibFc0NUVCJ46bVib0GkOQyXSwBdrPVqrPpSnwbZpdsuiajVKypicmocdh5nYCSP3tAjGQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwolcxS62c1ZRibFc0NUVCJ46RyK6lYFdDkVRH2xMBjFoeo0MKGzfMSGVFfbMuPtwAFt8w8FnQUIxeQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwolcxS62c1ZRibFc0NUVCJ46UzHy4WvRpicUaNuqIibhPJcyRiacqeDZx0MX9sqkibCsIJDMbujC6IqA8w/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwolcxS62c1ZRibFc0NUVCJ46Lv6akrqjicm78bMNVmo3SiaCPOiaYokVwHGia82tDn4Xaw1wHIXVkB7yBA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwolcxS62c1ZRibFc0NUVCJ46EJickksDhHBUDOsZw10M4PARys1wiaBeK3wDx2frGnnxFt02Kv2tGiaDQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwolcxS62c1ZRibFc0NUVCJ46jP61gF0DeUkU7SFic0yMK3cjpcbQqt3j6t0lEKSZUrvXpRYoN7dacVw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwolcxS62c1ZRibFc0NUVCJ46DTCVLYKALXJpjB3Glp2bjPzVS3s8dASJeZ2wUfo0rlM2O7ic8y7Eib2g/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="article:published_time" content="2022-05-16T13:10:12.678Z">
<meta property="article:modified_time" content="2022-05-17T13:37:15.552Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="Project">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pica.zhimg.com/80/v2-be49bb55a09595a9ca8653ba5f8f3b14_720w.jpg?source=1940ef5c">
  <!-- Canonical links -->
  <link rel="canonical" href="http://example.com/2022/05/16/C++%20%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/index.html">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
  
<meta name="generator" content="Hexo 6.2.0"></head>


<body class="main-center" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://github.com/Miracle-Pig" target="_blank">
          <img class="img-circle img-rotate" src="/images/avatar.jpg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">Miracle-Pig</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md">Web Developer &amp; Designer</h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Guangzhou, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="Search" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="Type something..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav ">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">Home</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">Archives</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">Categories</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">Tags</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">Repository</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/Miracle-Pig" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">Board</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p>Miracle-Pig</p> <p>中大软工硕士</p> <p>擅长:C&C++ liunx平台后台开发</p> <p>研究邻域:并行计算</p> <p>欢迎各位大佬交流经验!!!</p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">Categories</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E5%B7%A7/">技巧</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%A0%94%E7%A9%B6/">研究</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%A0%94%E7%A9%B6/%E9%A1%B9%E7%9B%AE/">项目</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%AD%E8%A8%80/">语言</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%A1%B9%E7%9B%AE/">项目</a><span class="category-list-count">1</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">Tags</h3>
    <div class="widget-body">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Algorithm-And-Data-Structure/" rel="tag">Algorithm And Data Structure</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C++</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Computer-Networks/" rel="tag">Computer Networks</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Operating-System/" rel="tag">Operating System</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Project/" rel="tag">Project</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Research/" rel="tag">Research</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQL/" rel="tag">SQL</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Skills/" rel="tag">Skills</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget-body tagcloud">
      <a href="/tags/Algorithm-And-Data-Structure/" style="font-size: 13px;">Algorithm And Data Structure</a> <a href="/tags/C/" style="font-size: 14px;">C++</a> <a href="/tags/Computer-Networks/" style="font-size: 13px;">Computer Networks</a> <a href="/tags/Operating-System/" style="font-size: 13px;">Operating System</a> <a href="/tags/Project/" style="font-size: 13px;">Project</a> <a href="/tags/Research/" style="font-size: 13px;">Research</a> <a href="/tags/SQL/" style="font-size: 13px;">SQL</a> <a href="/tags/Skills/" style="font-size: 13px;">Skills</a>
    </div>
  </div>

    
      
  <div class="widget">
    <h3 class="widget-title">Archive</h3>
    <div class="widget-body">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">May 2022</a><span class="archive-list-count">8</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E7%A0%94%E7%A9%B6/">研究</a><i class="icon icon-angle-right"></i><a class="category-link" href="/categories/%E7%A0%94%E7%A9%B6/%E9%A1%B9%E7%9B%AE/">项目</a>
              </p>
              <p class="item-title">
                <a href="/2022/05/17/MPI%20Spike%20Solver/" class="title">MPI Spike Solver</a>
              </p>
              <p class="item-date">
                <time datetime="2022-05-17T06:22:51.208Z" itemprop="datePublished">2022-05-17</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E6%8A%80%E5%B7%A7/">技巧</a>
              </p>
              <p class="item-title">
                <a href="/2022/05/17/Essential%20Skills/" class="title">Essential Skills</a>
              </p>
              <p class="item-date">
                <time datetime="2022-05-17T05:39:11.128Z" itemprop="datePublished">2022-05-17</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
              </p>
              <p class="item-title">
                <a href="/2022/05/17/MySQL/" class="title">MySQL</a>
              </p>
              <p class="item-date">
                <time datetime="2022-05-17T05:35:42.997Z" itemprop="datePublished">2022-05-17</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a>
              </p>
              <p class="item-title">
                <a href="/2022/05/17/Computer%20Networks/" class="title">Computer Networks</a>
              </p>
              <p class="item-date">
                <time datetime="2022-05-17T05:30:39.849Z" itemprop="datePublished">2022-05-17</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a>
              </p>
              <p class="item-title">
                <a href="/2022/05/16/Operating%20System/" class="title">Operating System</a>
              </p>
              <p class="item-date">
                <time datetime="2022-05-16T15:46:36.945Z" itemprop="datePublished">2022-05-16</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
  <aside class="sidebar sidebar-toc collapse   in  " id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">Catalogue</h3>
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97"><span class="toc-number">2.</span> <span class="toc-text">日志模块</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="toc-number">2.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6"><span class="toc-number">2.2.</span> <span class="toc-text">组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9B%BE"><span class="toc-number">2.3.</span> <span class="toc-text">类图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E4%BD%93%E9%80%BB%E8%BE%91"><span class="toc-number">2.4.</span> <span class="toc-text">整体逻辑</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%A8%A1%E5%9D%97"><span class="toc-number">3.</span> <span class="toc-text">配置模块</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-2"><span class="toc-number">3.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6-1"><span class="toc-number">3.2.</span> <span class="toc-text">组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E4%BD%93%E9%80%BB%E8%BE%91-1"><span class="toc-number">3.3.</span> <span class="toc-text">整体逻辑</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%94%81%E6%A8%A1%E5%9D%97"><span class="toc-number">4.</span> <span class="toc-text">锁模块</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-3"><span class="toc-number">4.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6-2"><span class="toc-number">4.2.</span> <span class="toc-text">组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E4%BD%93%E9%80%BB%E8%BE%91-2"><span class="toc-number">4.3.</span> <span class="toc-text">整体逻辑</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9D%97"><span class="toc-number">5.</span> <span class="toc-text">线程模块</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-4"><span class="toc-number">5.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BD%95%E4%B8%8D%E7%94%A8C-11%E7%9A%84%E7%BA%BF%E7%A8%8B"><span class="toc-number">5.2.</span> <span class="toc-text">为何不用C++11的线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6-3"><span class="toc-number">5.3.</span> <span class="toc-text">组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E4%BD%93%E9%80%BB%E8%BE%91-3"><span class="toc-number">5.4.</span> <span class="toc-text">整体逻辑</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E6%A8%A1%E5%9D%97"><span class="toc-number">6.</span> <span class="toc-text">协程模块</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-5"><span class="toc-number">6.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6-4"><span class="toc-number">6.2.</span> <span class="toc-text">组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E4%BD%93%E9%80%BB%E8%BE%91-4"><span class="toc-number">6.3.</span> <span class="toc-text">整体逻辑</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%9D%97"><span class="toc-number">7.</span> <span class="toc-text">协程调度模块</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-6"><span class="toc-number">7.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6-5"><span class="toc-number">7.2.</span> <span class="toc-text">组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E4%BD%93%E9%80%BB%E8%BE%91-5"><span class="toc-number">7.3.</span> <span class="toc-text">整体逻辑</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95"><span class="toc-number">7.4.</span> <span class="toc-text">测试</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8%E6%A8%A1%E5%9D%97"><span class="toc-number">8.</span> <span class="toc-text">定时器模块</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-7"><span class="toc-number">8.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6-6"><span class="toc-number">8.2.</span> <span class="toc-text">组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E4%BD%93%E9%80%BB%E8%BE%91-6"><span class="toc-number">8.3.</span> <span class="toc-text">整体逻辑</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95-1"><span class="toc-number">8.4.</span> <span class="toc-text">测试</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#IO%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%9D%97"><span class="toc-number">9.</span> <span class="toc-text">IO协程调度模块</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-8"><span class="toc-number">9.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6-7"><span class="toc-number">9.2.</span> <span class="toc-text">组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E4%BD%93%E9%80%BB%E8%BE%91-7"><span class="toc-number">9.3.</span> <span class="toc-text">整体逻辑</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95-2"><span class="toc-number">9.4.</span> <span class="toc-text">测试</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%8F%A5%E6%9F%84%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97"><span class="toc-number">10.</span> <span class="toc-text">文件句柄管理模块</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-9"><span class="toc-number">10.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6-8"><span class="toc-number">10.2.</span> <span class="toc-text">组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E4%BD%93%E9%80%BB%E8%BE%91-8"><span class="toc-number">10.3.</span> <span class="toc-text">整体逻辑</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95-3"><span class="toc-number">10.4.</span> <span class="toc-text">测试</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HOOK%E6%A8%A1%E5%9D%97"><span class="toc-number">11.</span> <span class="toc-text">HOOK模块</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-10"><span class="toc-number">11.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6-9"><span class="toc-number">11.2.</span> <span class="toc-text">组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E4%BD%93%E9%80%BB%E8%BE%91-9"><span class="toc-number">11.3.</span> <span class="toc-text">整体逻辑</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E6%A8%A1%E5%9D%97"><span class="toc-number">12.</span> <span class="toc-text">网络地址模块</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD"><span class="toc-number">12.1.</span> <span class="toc-text">功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9B%BE-1"><span class="toc-number">12.2.</span> <span class="toc-text">类图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6-10"><span class="toc-number">12.3.</span> <span class="toc-text">组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E4%BD%93%E9%80%BB%E8%BE%91-10"><span class="toc-number">12.4.</span> <span class="toc-text">整体逻辑</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95-4"><span class="toc-number">12.5.</span> <span class="toc-text">测试</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#socket%E5%B0%81%E8%A3%85%E6%A8%A1%E5%9D%97"><span class="toc-number">13.</span> <span class="toc-text">socket封装模块</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-11"><span class="toc-number">13.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6-11"><span class="toc-number">13.2.</span> <span class="toc-text">组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E4%BD%93%E9%80%BB%E8%BE%91-11"><span class="toc-number">13.3.</span> <span class="toc-text">整体逻辑</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95-5"><span class="toc-number">13.4.</span> <span class="toc-text">测试</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%A8%A1%E5%9D%97"><span class="toc-number">14.</span> <span class="toc-text">序列化与反序列化模块!!!</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-12"><span class="toc-number">14.1.</span> <span class="toc-text">概述</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9D%97"><span class="toc-number">15.</span> <span class="toc-text">网络模块</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-13"><span class="toc-number">15.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6-12"><span class="toc-number">15.2.</span> <span class="toc-text">组件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E8%AF%B7%E6%B1%82-x2F-%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%E5%B0%81%E8%A3%85"><span class="toc-number">15.2.1.</span> <span class="toc-text">HTTP请求&#x2F;响应报文封装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E8%A7%A3%E6%9E%90%E5%B0%81%E8%A3%85"><span class="toc-number">15.2.2.</span> <span class="toc-text">HTTP解析封装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E7%BB%93%E6%9E%84"><span class="toc-number">15.2.3.</span> <span class="toc-text">流结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Socket%E6%B5%81"><span class="toc-number">15.2.4.</span> <span class="toc-text">Socket流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-Session%E5%B0%81%E8%A3%85"><span class="toc-number">15.2.5.</span> <span class="toc-text">HTTP Session封装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">15.2.6.</span> <span class="toc-text">TCP服务器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Servlet"><span class="toc-number">15.2.7.</span> <span class="toc-text">Servlet</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">15.2.8.</span> <span class="toc-text">HTTP服务器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%EF%BC%88%E4%BF%9D%E6%8A%A4%EF%BC%89"><span class="toc-number">15.3.</span> <span class="toc-text">成员函数（保护）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#PS"><span class="toc-number">16.</span> <span class="toc-text">PS</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-14"><span class="toc-number">16.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6-13"><span class="toc-number">16.2.</span> <span class="toc-text">组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E4%BD%93%E9%80%BB%E8%BE%91-12"><span class="toc-number">16.3.</span> <span class="toc-text">整体逻辑</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95-6"><span class="toc-number">16.4.</span> <span class="toc-text">测试</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8A%A5%E9%94%99%E4%B8%8E%E8%B0%83%E8%AF%95"><span class="toc-number">17.</span> <span class="toc-text">报错与调试</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9C%80%E8%A6%81%E7%A0%94%E7%A9%B6%E7%9A%84%E5%BC%80%E5%8F%91%E6%9C%BA%E5%88%B6"><span class="toc-number">18.</span> <span class="toc-text">需要研究的开发机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B"><span class="toc-number">18.1.</span> <span class="toc-text">协程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#epoll"><span class="toc-number">18.2.</span> <span class="toc-text">epoll</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LINUX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-number">18.3.</span> <span class="toc-text">LINUX网络编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Socket"><span class="toc-number">18.3.1.</span> <span class="toc-text">Socket</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%8F%A5%E6%9F%84%E6%93%8D%E4%BD%9C"><span class="toc-number">18.3.2.</span> <span class="toc-text">文件句柄操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7"><span class="toc-number">18.3.3.</span> <span class="toc-text">信号</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">18.4.</span> <span class="toc-text">序列化与反序列化</span></a></li></ol></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-C++ 高性能服务器框架开发日志" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      C++ 高性能服务器框架日志
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2022/05/16/C++%20%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/" class="article-date">
	  <time datetime="2022-05-16T13:10:12.678Z" itemprop="datePublished">2022-05-16</time>
	</a>
</span>
        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/%E9%A1%B9%E7%9B%AE/">项目</a>
  </span>

        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link-link" href="/tags/C/" rel="tag">C++</a>, <a class="article-tag-link-link" href="/tags/Project/" rel="tag">Project</a>
  </span>


        

        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/2022/05/16/C++%20%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/#comments" class="article-comment-link">Comments</a></span>
        
      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul>
<li>C++ 高性能服务器框架（High Performance Server&#x2F;HPS）</li>
<li>可作为WEB、数据库、游戏等服务器</li>
<li>框架提供基本的线程、协程库，IO库，TCP、HTTP网络应用接口</li>
</ul>
<h1 id="日志模块"><a href="#日志模块" class="headerlink" title="日志模块"></a>日志模块</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><ul>
<li>功能：向文件或者控制台输出服务器日志信息</li>
</ul>
<h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><ul>
<li>日志等级（LogLevel）<ul>
<li>unknow、debug、info、warn、error、fatal 6个级别，报告服务器的各种类型的日志信息</li>
</ul>
</li>
<li>日志事件（LogEvent）<ul>
<li>成员属性：包含输出每个日志项的所有属性，如下：<ul>
<li>日志级别</li>
<li>文件名</li>
<li>文件行号</li>
<li>程序启动依赖的耗时</li>
<li>线程id</li>
<li>协程id</li>
<li>日志时间</li>
<li>线程名称</li>
</ul>
</li>
</ul>
</li>
<li>日志格式器（LogFormatter）<ul>
<li>功能：使用log4j格式，对输入的格式字符串进行解析<ul>
<li>除使用默认格式外，可自定义日志格式</li>
<li>默认格式</li>
</ul>
</li>
</ul>
</li>
<li>日志格式项<ul>
<li>功能：对日志格式%号后的字母进行解析，如%p代表日志级别、%t代表线程id等</li>
</ul>
</li>
<li>日志输出器（LogAppender）<ul>
<li>输出到控制台:StdoutLogAppender</li>
<li>输出到文件:FileLogAppender</li>
</ul>
</li>
<li>日志器（Logger）</li>
<li>日志包装器（LogEventWrap）<ul>
<li>功能:执行整体日志逻辑</li>
<li>成员属性：<ul>
<li>日志事件</li>
</ul>
</li>
</ul>
</li>
<li>日志配置<ul>
<li>功能：使用.yml配置文件对日志器属性进行配置管理</li>
<li>结构体：<ul>
<li>日志配置<ul>
<li>成员属性：日志等级、日志格式、日志输出器、日志名称</li>
</ul>
</li>
<li>日志输出器配置<ul>
<li>成员属性：日志等级，日志输出文件、日志格式、日志输出类型</li>
</ul>
</li>
<li></li>
</ul>
</li>
<li>成员方法：<ul>
<li>Yaml String和日志配置、日志输出器配置之间的相互转换</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">classDiagram</span><br><span class="line">    LogEvent --&gt; Logger : 关联</span><br><span class="line">    Logger --&gt; LogFormatter : 关联</span><br><span class="line">    Logger --&gt; LogAppender : 关联</span><br><span class="line">    StdoutLogAppender ..|&gt; LogAppender : 实现</span><br><span class="line">    FileLogAppender ..|&gt; LogAppender : 实现</span><br><span class="line">    FormatterItem *-- LogFormatter : 组合</span><br><span class="line">    </span><br><span class="line">    class Logger&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    class LogEvent&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    class LogFormatter&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    class LogAppender&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    class StdoutLogAppender&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    class FileLogAppender&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="整体逻辑"><a href="#整体逻辑" class="headerlink" title="整体逻辑"></a>整体逻辑</h2><ul>
<li>日志管理器中有多个日志器，每个日志器可包含多个不同类型或者级别的日志输出器，均使用统一的日志事件</li>
</ul>
<ol>
<li><p>创建日志器,定义日志格式，并创建日志格式器</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Logger::Logger(const std::string &amp;name): m_name(name), m_level(LogLevel::DEBUG)</span><br><span class="line">&#123;</span><br><span class="line">    //! 创建日志格式器</span><br><span class="line">    m_formatter.reset(new LogFormatter(&quot;%d&#123;%Y-%m-%d %H:%M:%S&#125;%T%t%T%N%T%F%T[%p]%T[%c]%T%f:%l%T%m%n&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>创建日志格式器,解析日志格式，取得日志项数组（存储解析得到的日志项）</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LogFormatter::LogFormatter(const std::string &amp;pattern): m_pattern(pattern)</span><br><span class="line">&#123;</span><br><span class="line">    //! 对日志格式进行解析</span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>创建日志事件</p>
<ul>
<li>对服务器代码运行的文件、所在行、毫秒数、线程ID、协程ID、时间戳、线程名称、日志器、日志等级进行记录</li>
</ul>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LogEvent::LogEvent(std::shared_ptr&lt;Logger&gt; logger, LogLevel::Level level, const char *file, int32_t line, uint32_t elapse, uint32_t thread_id, uint32_t fiber_id, uint64_t time, const std::string &amp;thread_name)</span><br><span class="line">        : m_file(file), m_line(line), m_elapse(elapse), m_threadId(thread_id), m_fiberId(fiber_id), m_time(time), m_threadName(thread_name), m_logger(logger), m_level(level)</span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>创建日志输出器并添加<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void Logger::addAppender(LogAppender::ptr appender)</span><br></pre></td></tr></table></figure></li>
<li>使用日志包装器执行整体逻辑<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LogEventWrap::LogEventWrap(LogEvent::ptr e): m_event(e)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>获取日志事件中的日志器<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LogEventWrap::~LogEventWrap()</span><br><span class="line">&#123;</span><br><span class="line">    m_event-&gt;getLogger()-&gt;log(m_event-&gt;getLevel(), m_event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>日志器中遍历日志输出器数组<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void Logger::log(LogLevel::Level level, LogEvent::ptr event)</span><br><span class="line">&#123;</span><br><span class="line">    if (level &gt;= m_level)</span><br><span class="line">    &#123;</span><br><span class="line">        auto self = shared_from_this();</span><br><span class="line">        // MutexType::Lock lock(m_mutex);</span><br><span class="line">        if (!m_appenders.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            for (auto &amp;i : m_appenders)</span><br><span class="line">            &#123;</span><br><span class="line">                i-&gt;log(self, level, event);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (m_root)</span><br><span class="line">        &#123;</span><br><span class="line">            m_root-&gt;log(level, event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>日志输出器中遍历格式项数组<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">//!使用宏定义，定义日志格式容器</span><br><span class="line">        static std::map&lt;std::string, std::function&lt;FormatItem::ptr(const std::string &amp;str)&gt;&gt; s_format_items = &#123;</span><br><span class="line">#define XX(str, C)                                                               \</span><br><span class="line">    &#123;                                                                            \</span><br><span class="line">#str, [](const std::string &amp;fmt) &#123; return FormatItem::ptr(new C(fmt)); &#125; \</span><br><span class="line">    &#125;</span><br><span class="line">            XX(m, MessageFormatItem),  // m:消息</span><br><span class="line">            XX(p, LevelFormatItem),    // p:日志级别</span><br><span class="line">            XX(r, ElapseFormatItem),   // r:累计毫秒数</span><br><span class="line">            XX(c, NameFormatItem),     // c:日志名称</span><br><span class="line">            XX(t, ThreadIdFormatItem), // t:线程id</span><br><span class="line">            XX(n, NewLineFormatItem),  // n:换行</span><br><span class="line">            XX(d, DateTimeFormatItem), // d:时间</span><br><span class="line">            XX(f, FilenameFormatItem), // f:文件名</span><br><span class="line">            XX(l, LineFormatItem),     // l:行号</span><br><span class="line">            XX(T, TabFormatItem),      // T:Tab</span><br><span class="line">            XX(F, FiberIdFormatItem),  // F:协程id</span><br><span class="line">            XX(N, ThreadNameFormatItem),</span><br><span class="line">#undef XX</span><br><span class="line">        &#125;;</span><br><span class="line">    //! 格式项</span><br><span class="line">    class MessageFormatItem : public LogFormatter::FormatItem</span><br><span class="line">    &#123;</span><br><span class="line">    public:</span><br><span class="line">        MessageFormatItem(const std::string &amp;str = &quot;&quot;) &#123;&#125;</span><br><span class="line">        void format(std::ostream &amp;os, Logger::ptr logger, LogLevel::Level level, LogEvent::ptr event) override</span><br><span class="line">        &#123;</span><br><span class="line">            os &lt;&lt; event-&gt;getContent();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    void StdoutLogAppender::log(std::shared_ptr&lt;Logger&gt; logger, LogLevel::Level level, LogEvent::ptr event)</span><br><span class="line">    &#123;</span><br><span class="line">        if (level &gt;= m_level)</span><br><span class="line">        &#123;</span><br><span class="line">            // MutexType::Lock lock(m_mutex);</span><br><span class="line">            m_formatter-&gt;format(std::cout, logger, level, event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li>对每个日志项格式化放入到输出流中<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">std::ostream &amp;LogFormatter::format(std::ostream &amp;ofs, std::shared_ptr&lt;Logger&gt; logger, LogLevel::Level level, LogEvent::ptr event)</span><br><span class="line">&#123;</span><br><span class="line">    for (auto &amp;i : m_items)</span><br><span class="line">    &#123;</span><br><span class="line">        i-&gt;format(ofs, logger, level, event);</span><br><span class="line">    &#125;</span><br><span class="line">    return ofs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>最终获取每条日志的字符串输出流<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::stringstream &amp;LogEventWrap::getSS()</span><br><span class="line">&#123;</span><br><span class="line">    return m_event-&gt;getSS();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>使用流式方式将日志级别level的日志写入到logger<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#define LOG_LEVEL(logger, level) \</span><br><span class="line">    if (logger-&gt;getLevel() &lt;= level) \</span><br><span class="line">    HPS::LogEventWrap(HPS::LogEvent::ptr(new HPS::LogEvent(logger, level, \</span><br><span class="line">                        __FILE__, __LINE__, 0, 0, 0, time(0), &quot;&quot;))) \</span><br><span class="line">                        .getSS()</span><br><span class="line">#define LOG_DEBUG(logger) LOG_LEVEL(logger, HPS::LogLevel::DEBUG)</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>总结：每个日志器有自己的日志格式（LogFormatter）、日志输出器（LogAppender，输出到控制台StdoutLogAppender&#x2F;文件的日志输出器FileLogAppender），日志格式有输出各种信息的日志项（FormatItem），日志事件定义日志器需要输出的日志项</li>
</ul>
<h1 id="配置模块"><a href="#配置模块" class="headerlink" title="配置模块"></a>配置模块</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><ul>
<li>配置文件基于Yaml<h2 id="组件-1"><a href="#组件-1" class="headerlink" title="组件"></a>组件</h2></li>
<li>类型转换偏特化模板类（LexicalCast)<ul>
<li>C++偏特化<ul>
<li>Yaml string的不同类型与使用vector，list，map，unordered_map，set，unordered_set等容器存放的数据类型之间的相互转换</li>
</ul>
</li>
</ul>
</li>
<li>配置参数基类（ConfigVarBase）<ul>
<li>功能：对配置参数的基本信息进行存储、描述</li>
<li>成员函数<ul>
<li>配置参数和字符串的相互转换（虚函数）</li>
<li>返回配置参数数值的类型名称（虚函数）</li>
</ul>
</li>
<li>成员属性：<ul>
<li>配置参数名称</li>
<li>配置参数描述</li>
</ul>
</li>
</ul>
</li>
<li>配置参数模板子类，保存对应类型的参数值（ConfigVar）<ul>
<li>功能：对配置参数的基本信息、特定类型进行存储、描述</li>
<li>成员属性<ul>
<li>配置参数名称</li>
<li>配置参数描述</li>
<li>配置参数类型名称</li>
<li>所有配置项</li>
<li>变更回调数组</li>
</ul>
</li>
<li>成员函数<ul>
<li>将参数值转换为Yaml String</li>
<li>从YAML String 转成参数的值</li>
<li>获取当前参数的值、参数值的类型名称</li>
<li>对变更回调数组的增删改查</li>
<li>设置当前参数的值，若参数发生变化，则通知对应的注册回调函数(变更回调函数的作用???已解决:当Yaml 文件参数发生变化时，记录发生变换的过程)</li>
</ul>
</li>
<li>配置参数管理类（Config）<ul>
<li>功能：</li>
</ul>
</li>
<li>成员函数：<ul>
<li>获取&#x2F;创建对应参数名的配置参数（通过配置参数名以及配置类型，或者只通过配置参数名 ）</li>
<li>使用yaml node初始化配置模块</li>
<li>加载配置文件</li>
<li>返回配置参数基类</li>
<li>遍历配置模块所有配置项<h2 id="整体逻辑-1"><a href="#整体逻辑-1" class="headerlink" title="整体逻辑"></a>整体逻辑</h2></li>
</ul>
</li>
</ul>
</li>
</ul>
<ol>
<li>首先通过参数名称、参数值、参数描述创建并添加配置参数子类对象到所有配置项<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HPS::ConfigVar&lt;std::vector&lt;int&gt; &gt;::ptr g_int_vec_value_config =</span><br><span class="line">HPS::Config::Lookup(&quot;system.int_vec&quot;, std::vector&lt;int&gt;&#123;1,2&#125;, &quot;system int vec&quot;);</span><br></pre></td></tr></table></figure></li>
<li>从.yml文件中导入根yaml node<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">YAML::Node root = YAML::LoadFile(&quot;/home/Zone/workspace/HPS/bin/conf/test.yml&quot;);</span><br></pre></td></tr></table></figure></li>
<li>从yaml root node开始，递归(因为有map类型)提取.yml文件中的所有yaml node存储到list容器中<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static void ListAllMember(const std::string &amp;prefix,</span><br><span class="line">                          const YAML::Node &amp;node,</span><br><span class="line">                          std::list&lt;std::pair&lt;std::string, const YAML::Node&gt;&gt; &amp;output)</span><br></pre></td></tr></table></figure></li>
<li>遍历list容器，将各yaml node转为配置参数<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">void Config::LoadFromYaml(const YAML::Node &amp;root)</span><br><span class="line">&#123;</span><br><span class="line">    std::list&lt;std::pair&lt;std::string, const YAML::Node&gt;&gt; all_nodes;</span><br><span class="line">    ListAllMember(&quot;&quot;, root, all_nodes);</span><br><span class="line">    for (auto &amp;i : all_nodes)</span><br><span class="line">    &#123;</span><br><span class="line">        std::string key = i.first;</span><br><span class="line">        if (key.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::transform(key.begin(), key.end(), key.begin(), ::tolower);</span><br><span class="line">        //! 遍历所有yaml node，通过配置参数名查找到配置参数基类</span><br><span class="line">        ConfigVarBase::ptr var = LookupBase(key);</span><br><span class="line"></span><br><span class="line">        if (var)</span><br><span class="line">        &#123;</span><br><span class="line">            if (i.second.IsScalar())</span><br><span class="line">            &#123;</span><br><span class="line">                var-&gt;fromString(i.second.Scalar());</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                std::stringstream ss;</span><br><span class="line">                ss &lt;&lt; i.second;</span><br><span class="line">                var-&gt;fromString(ss.str());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>如何转换？<br>  4.1 遍历所有yaml node，<br>  4.2 通过配置参数名查找到配置参数基类  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ConfigVarBase::ptr var = LookupBase(key);</span><br></pre></td></tr></table></figure>
  4.3 若yaml node为scalar直接转为yaml node；若yaml node非scalar则通过yaml字符串转为yaml node  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if (i.second.IsScalar())</span><br><span class="line">&#123;</span><br><span class="line">    var-&gt;fromString(i.second.Scalar());</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">    std::stringstream ss;</span><br><span class="line">    ss &lt;&lt; i.second;</span><br><span class="line">    var-&gt;fromString(ss.str());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  4.3 使用类型转换模板类偏特化，将Yaml string转换为存储相应类型的容器，如vector：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">FromStr()(val);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @brief 类型转换模板类片特化(YAML String 转换成 std::vector&lt;T&gt;)</span><br><span class="line"> /</span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">class LexicalCast&lt;std::string, std::vector&lt;T&gt;&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    std::vector&lt;T&gt; operator()(const std::string &amp;v)</span><br><span class="line">    &#123;</span><br><span class="line">        YAML::Node node = YAML::Load(v);</span><br><span class="line">        //! yaml node转换为数组类型</span><br><span class="line">        typename std::vector&lt;T&gt; vec;</span><br><span class="line">        std::stringstream ss;</span><br><span class="line">        for (size_t i = 0; i &lt; node.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            ss.str(&quot;&quot;);</span><br><span class="line">            ss &lt;&lt; node[i];</span><br><span class="line">            //! 字符串转换为简单类型</span><br><span class="line">            vec.push_back(LexicalCast&lt;std::string, T&gt;()(ss.str()));</span><br><span class="line">        &#125;</span><br><span class="line">        return vec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
  4.4 转换之后，设定模板参数子类对象的值类型为其转换后的容器类型  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">setValue(FromStr()(val));</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @brief 从YAML String 转成参数的值</span><br><span class="line"> * @exception 当转换失败抛出异常</span><br><span class="line"> */</span><br><span class="line">bool fromString(const std::string &amp;val) override</span><br><span class="line">&#123;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">        //! 将Yaml格式字符串m_val类型的Yaml Node</span><br><span class="line">        setValue(FromStr()(val));</span><br><span class="line">    &#125;</span><br><span class="line">    catch (std::exception &amp;e)</span><br><span class="line">    &#123;</span><br><span class="line">        LOG_ERROR(LOG_ROOT()) &lt;&lt; &quot;ConfigVar::fromString exception &quot;</span><br><span class="line">                              &lt;&lt; e.what() &lt;&lt; &quot; convert: string to &quot; &lt;&lt; TypeToName&lt;T&gt;()</span><br><span class="line">                              &lt;&lt; &quot; name=&quot; &lt;&lt; m_name</span><br><span class="line">                              &lt;&lt; &quot; - &quot; &lt;&lt; val;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @brief 设置当前参数的值</span><br><span class="line"> * @detail 如果参数的值有发生变化,则通知对应的注册回调函数</span><br><span class="line"> */</span><br><span class="line">void setValue(const T &amp;v)</span><br><span class="line">&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        // RWMutexType::ReadLock lock(m_mutex);</span><br><span class="line">        if (v == m_val)</span><br><span class="line">        &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (auto &amp;i : m_cbs)</span><br><span class="line">        &#123;</span><br><span class="line">            i.second(m_val, v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // RWMutexType::WriteLock lock(m_mutex);</span><br><span class="line">    m_val = v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="锁模块"><a href="#锁模块" class="headerlink" title="锁模块"></a>锁模块</h1><h2 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h2><ul>
<li><p>对semaphore.h信号量，pthread.h锁模块进行封装</p>
<h2 id="组件-2"><a href="#组件-2" class="headerlink" title="组件"></a>组件</h2></li>
<li><p>信号量（禁止拷贝）</p>
<ul>
<li>成员属性：<ul>
<li>信号量</li>
</ul>
</li>
<li>成员方法：<ul>
<li>获取信号量</li>
<li>释放信号量</li>
</ul>
</li>
</ul>
</li>
<li><p>局部锁模板类</p>
<ul>
<li>分为局部锁、局部读锁、局部写锁</li>
<li><strong>为了更加同意方便的使用各种类型的锁（类似于多态继承）</strong></li>
<li>成员属性<ul>
<li>互斥量</li>
<li>是否上锁</li>
</ul>
</li>
<li>成员方法<ul>
<li>加锁</li>
<li>解锁</li>
</ul>
</li>
</ul>
</li>
<li><p>互斥量（Mutex）</p>
<ul>
<li>对pthread_mutex进行封装</li>
</ul>
</li>
<li><p>空锁（NullMutex）</p>
<ul>
<li>用于调试</li>
</ul>
</li>
<li><p>读写锁（RWMutex）</p>
<ul>
<li>对pthread_rwlock进行封装</li>
<li>控制存在读写的临界区</li>
</ul>
</li>
<li><p>自旋锁（Spinlock）</p>
<ul>
<li>对pthread_spinlock进行封装</li>
<li>线程不会放弃CPU时间片，而是通过自旋等待锁的释放，就是说，会不停地再次地尝试获取锁，若失败就再次尝试，直到成功为止</li>
<li>优势：在同步代码块内容不复杂，即执行时间很短的情况下，自旋锁用循环去不停地尝试获取锁，让线程始终处于 Runnable 状态，节省了线程状态切换带来的开销</li>
<li>缺点：如果这把锁一直不能被释放，那么这种尝试只是无用的尝试，会白白浪费处理器资源，虽然一开始自旋锁的开销低于线程切换，但是随着时间的增加</li>
<li>适用场景：自旋锁适用于并发度不是特别高的场景，以及临界区比较短小的情况，这样我们可以利用避免线程切换来提高效率。因为如果临界区很大，线程一旦拿到锁，很久才会释放的话，那就不合适用自旋锁，因为自旋会一直占用 CPU 却无法拿到锁，白白消耗资源。</li>
</ul>
</li>
<li><p>原子锁（CASLock）</p>
<ul>
<li>对atomic_flag进行封装</li>
<li>将代码和指令对应起来，使得代码执行变为原子操作，相较于互斥锁是操作系统这一层级的，而原子锁是CPU这一层级的</li>
</ul>
</li>
<li><p>以上锁使用方法，以互斥量为例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef Mutex MutexType;</span><br><span class="line">MutexType mutex;</span><br><span class="line">MutexType::Lock lock(mutex)</span><br><span class="line">//临界区代码</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="整体逻辑-2"><a href="#整体逻辑-2" class="headerlink" title="整体逻辑"></a>整体逻辑</h2><h1 id="线程模块"><a href="#线程模块" class="headerlink" title="线程模块"></a>线程模块</h1><h2 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h2><ul>
<li>对pthread进行封装，向用户提供使用线程的接口</li>
<li><h2 id="为何不用C-11的线程"><a href="#为何不用C-11的线程" class="headerlink" title="为何不用C++11的线程"></a>为何不用C++11的线程</h2><h2 id="组件-3"><a href="#组件-3" class="headerlink" title="组件"></a>组件</h2></li>
<li>线程（禁止拷贝）<ul>
<li>成员属性：<ul>
<li>线程id：</li>
<li>线程结构：</li>
<li>线程执行函数</li>
<li>线程名称</li>
<li>信号量</li>
</ul>
</li>
<li>成员函数<ul>
<li>线程的创建与销毁（构造与析构）</li>
<li>返回线程ID、名称</li>
<li>获取当前的线程指针、线程名称，设置当前线程名称（静态）</li>
<li>等待线程执行完成</li>
<li>线程执行函数（静态）<h2 id="整体逻辑-3"><a href="#整体逻辑-3" class="headerlink" title="整体逻辑"></a>整体逻辑</h2></li>
</ul>
</li>
</ul>
</li>
</ul>
<ol>
<li>创建线程</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Thread::Thread(std::function&lt;void()&gt; cb, const std::string &amp;name)</span><br><span class="line">    : m_cb(cb), m_name(name)</span><br><span class="line">&#123;</span><br><span class="line">    if (name.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        m_name = &quot;UNKNOW&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    int rt = pthread_create(&amp;m_thread, nullptr, &amp;Thread::run, this);</span><br><span class="line">    if (rt)</span><br><span class="line">    &#123;</span><br><span class="line">        LOG_ERROR(g_logger) &lt;&lt; &quot;pthread_create thread fail, rt=&quot; &lt;&lt; rt</span><br><span class="line">                                  &lt;&lt; &quot; name=&quot; &lt;&lt; name;</span><br><span class="line">        throw std::logic_error(&quot;pthread_create error&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //! 与下方notify对应</span><br><span class="line">    m_semaphore.wait();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>线程执行函数<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void *Thread::run(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">    Thread *thread = (Thread *)arg;</span><br><span class="line">    t_thread = thread;</span><br><span class="line">    t_thread_name = thread-&gt;m_name;</span><br><span class="line">    thread-&gt;m_id = HPS::GetThreadId();</span><br><span class="line">    pthread_setname_np(pthread_self(), thread-&gt;m_name.substr(0, 15).c_str());</span><br><span class="line"></span><br><span class="line">    std::function&lt;void()&gt; cb;</span><br><span class="line">    cb.swap(thread-&gt;m_cb);</span><br><span class="line">    //！ 必须在线程所有属性都初始化完毕后才执行线程函数</span><br><span class="line">    thread-&gt;m_semaphore.notify();</span><br><span class="line">    </span><br><span class="line">    cb();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>回收线程<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void Thread::join()</span><br><span class="line">&#123;</span><br><span class="line">    if (m_thread)</span><br><span class="line">    &#123;</span><br><span class="line">        int rt = pthread_join(m_thread, nullptr);</span><br><span class="line">        if (rt)</span><br><span class="line">        &#123;</span><br><span class="line">            LOG_ERROR(g_logger) &lt;&lt; &quot;pthread_join thread fail, rt=&quot; &lt;&lt; rt</span><br><span class="line">                                &lt;&lt; &quot; name=&quot; &lt;&lt; m_name;</span><br><span class="line">            throw std::logic_error(&quot;pthread_join error&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        m_thread = 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>销毁线程<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Thread::~Thread()</span><br><span class="line">&#123;</span><br><span class="line">    if (m_thread)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_detach(m_thread);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="协程模块"><a href="#协程模块" class="headerlink" title="协程模块"></a>协程模块</h1><h2 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h2><pre><code>- 功能
</code></pre>
<h2 id="组件-4"><a href="#组件-4" class="headerlink" title="组件"></a>组件</h2><ul>
<li>协程类（Fiber）<ul>
<li>成员属性<ul>
<li>协程ID、状态</li>
<li>协程上下文</li>
<li>协程运行栈大小、栈指针</li>
<li>协程运行函数</li>
</ul>
</li>
<li>成员函数<ul>
<li>协程的创建和销毁</li>
<li>重置协程执行函数,并设置状态</li>
<li>将当前协程切换到运行状态</li>
<li>将当前协程切换到后台</li>
<li>返回协程id、状态</li>
<li>设置、返回当前线程的运行协程（静态）</li>
<li>返回当前所在的协程、总数量（静态）</li>
<li>将当前协程切换到后台,并设置为READY、HOLD状态（静态）<ul>
<li>置为READY、HOLD状态后，使用back跳转回线程主协程</li>
<li>在使用call后，将协程置为运行状态，切入到运行协程执行该方法之后的代码</li>
</ul>
</li>
<li>协程执行函数（静态）<h2 id="整体逻辑-4"><a href="#整体逻辑-4" class="headerlink" title="整体逻辑"></a>整体逻辑</h2></li>
</ul>
</li>
</ul>
</li>
</ul>
<ol>
<li><p>创建协程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">//！ 有参构造（公共）</span><br><span class="line">Fiber::Fiber(std::function&lt;void()&gt; cb, size_t stacksize, bool use_caller)</span><br><span class="line">    : m_id(++s_fiber_id), m_cb(cb)</span><br><span class="line">&#123;</span><br><span class="line">    //! 分配协程栈指针和大小</span><br><span class="line">    ++s_fiber_count;</span><br><span class="line">    m_stacksize = stacksize ? stacksize : g_fiber_stack_size-&gt;getValue();</span><br><span class="line">    m_stack = StackAllocator::Alloc(m_stacksize);</span><br><span class="line">    //! 初始化协程上下文</span><br><span class="line">    if (getcontext(&amp;m_ctx))</span><br><span class="line">    &#123;</span><br><span class="line">        ASSERT2(false, &quot;getcontext&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //! 将协程栈指针和大小赋值给协程上下文</span><br><span class="line">    m_ctx.uc_link = nullptr;</span><br><span class="line">    m_ctx.uc_stack.ss_sp = m_stack;</span><br><span class="line">    m_ctx.uc_stack.ss_size = m_stacksize;</span><br><span class="line">    //! 将协程执行函数分配给协程上下文</span><br><span class="line">    if (!use_caller)</span><br><span class="line">    &#123;</span><br><span class="line">        makecontext(&amp;m_ctx, &amp;Fiber::MainFunc, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        makecontext(&amp;m_ctx, &amp;Fiber::CallerMainFunc, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LOG_DEBUG(g_logger) &lt;&lt; &quot;Fiber::Fiber id=&quot; &lt;&lt; m_id;</span><br><span class="line">&#125;</span><br><span class="line">//! 无参构造创建主协程，所以必须为私有方法，外部不能随意创建</span><br><span class="line">Fiber::Fiber()</span><br><span class="line">&#123;</span><br><span class="line">    m_state = EXEC;</span><br><span class="line">    //! 创建时将本协程设为当前协程</span><br><span class="line">    SetThis(this);</span><br><span class="line">    //! 初始化协程上下文</span><br><span class="line">    if (getcontext(&amp;m_ctx))</span><br><span class="line">    &#123;</span><br><span class="line">        ASSERT2(false, &quot;getcontext&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ++s_fiber_count;</span><br><span class="line"></span><br><span class="line">    LOG_DEBUG(g_logger) &lt;&lt; &quot;Fiber::Fiber main&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>返回当前协程，若当前线程不存在任何协程，则创建主协程并返回</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Fiber::ptr Fiber::GetThis()</span><br><span class="line">    &#123;</span><br><span class="line">        if (t_fiber)</span><br><span class="line">        &#123;</span><br><span class="line">            return t_fiber-&gt;shared_from_this();</span><br><span class="line">        &#125;</span><br><span class="line">        Fiber::ptr main_fiber(new Fiber);</span><br><span class="line">        ASSERT(t_fiber == main_fiber.get());</span><br><span class="line">        t_threadFiber = main_fiber;</span><br><span class="line">        return t_fiber-&gt;shared_from_this();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<ol start="3">
<li><p>协程执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">void Fiber::CallerMainFunc()</span><br><span class="line">&#123;</span><br><span class="line">    Fiber::ptr cur = GetThis();</span><br><span class="line">    ASSERT(cur);</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">        cur-&gt;m_cb();</span><br><span class="line">        cur-&gt;m_cb = nullptr;</span><br><span class="line">        //! 运行完毕后，置协程状态为终止</span><br><span class="line">        cur-&gt;m_state = TERM;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (std::exception &amp;ex)</span><br><span class="line">    &#123;</span><br><span class="line">        //! 若捕捉到异常，则置协程状态为异常</span><br><span class="line">        cur-&gt;m_state = EXCEPT;</span><br><span class="line">        LOG_ERROR(g_logger) &lt;&lt; &quot;Fiber Except: &quot; &lt;&lt; ex.what()</span><br><span class="line">                            &lt;&lt; &quot; fiber_id=&quot; &lt;&lt; cur-&gt;getId()</span><br><span class="line">                            &lt;&lt; std::endl</span><br><span class="line">                            &lt;&lt; HPS::BacktraceToString();</span><br><span class="line">    &#125;</span><br><span class="line">    catch (...)</span><br><span class="line">    &#123;</span><br><span class="line">        cur-&gt;m_state = EXCEPT;</span><br><span class="line">        LOG_ERROR(g_logger) &lt;&lt; &quot;Fiber Except&quot;</span><br><span class="line">                            &lt;&lt; &quot; fiber_id=&quot; &lt;&lt; cur-&gt;getId()</span><br><span class="line">                            &lt;&lt; std::endl</span><br><span class="line">                            &lt;&lt; HPS::BacktraceToString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    auto raw_ptr = cur.get();</span><br><span class="line">    //! 首先将cur与原始指针分离</span><br><span class="line">    cur.reset();</span><br><span class="line">    //! 然后切换回主协程</span><br><span class="line">    raw_ptr-&gt;back();</span><br><span class="line">    ASSERT2(false, &quot;never reach fiber_id=&quot; + std::to_string(raw_ptr-&gt;getId()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>主协程切换至运行协程</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void Fiber::call()</span><br><span class="line">    &#123;</span><br><span class="line">        SetThis(this);</span><br><span class="line">        m_state = EXEC;</span><br><span class="line">        //! 切换协程上下文</span><br><span class="line">        if (swapcontext(&amp;t_threadFiber-&gt;m_ctx, &amp;m_ctx))</span><br><span class="line">        &#123;</span><br><span class="line">            ASSERT2(false, &quot;swapcontext&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>协程执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">void Fiber::CallerMainFunc()</span><br><span class="line">&#123;</span><br><span class="line">    Fiber::ptr cur = GetThis();</span><br><span class="line">    ASSERT(cur);</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">        cur-&gt;m_cb();</span><br><span class="line">        cur-&gt;m_cb = nullptr;</span><br><span class="line">        //! 运行完毕后，置协程状态为终止</span><br><span class="line">        cur-&gt;m_state = TERM;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (std::exception &amp;ex)</span><br><span class="line">    &#123;</span><br><span class="line">        //! 若捕捉到异常，则置协程状态为异常</span><br><span class="line">        cur-&gt;m_state = EXCEPT;</span><br><span class="line">        LOG_ERROR(g_logger) &lt;&lt; &quot;Fiber Except: &quot; &lt;&lt; ex.what()</span><br><span class="line">                            &lt;&lt; &quot; fiber_id=&quot; &lt;&lt; cur-&gt;getId()</span><br><span class="line">                            &lt;&lt; std::endl</span><br><span class="line">                            &lt;&lt; HPS::BacktraceToString();</span><br><span class="line">    &#125;</span><br><span class="line">    catch (...)</span><br><span class="line">    &#123;</span><br><span class="line">        cur-&gt;m_state = EXCEPT;</span><br><span class="line">        LOG_ERROR(g_logger) &lt;&lt; &quot;Fiber Except&quot;</span><br><span class="line">                            &lt;&lt; &quot; fiber_id=&quot; &lt;&lt; cur-&gt;getId()</span><br><span class="line">                            &lt;&lt; std::endl</span><br><span class="line">                            &lt;&lt; HPS::BacktraceToString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    auto raw_ptr = cur.get();</span><br><span class="line">    //! 首先将cur与原始指针分离</span><br><span class="line">    cur.reset();</span><br><span class="line">    //! 然后切换回主协程</span><br><span class="line">    raw_ptr-&gt;back();</span><br><span class="line">    ASSERT2(false, &quot;never reach fiber_id=&quot; + std::to_string(raw_ptr-&gt;getId()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>协程运行完毕后切换至主协程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void Fiber::back()</span><br><span class="line">&#123;</span><br><span class="line">    SetThis(t_threadFiber.get());</span><br><span class="line">    //! 切换协程上下文</span><br><span class="line">    if (swapcontext(&amp;m_ctx, &amp;t_threadFiber-&gt;m_ctx))</span><br><span class="line">    &#123;</span><br><span class="line">        ASSERT2(false, &quot;swapcontext&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>销毁协程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Fiber::~Fiber()</span><br><span class="line">&#123;</span><br><span class="line">    --s_fiber_count;</span><br><span class="line">    //! 有协程栈时，说明为其他协程，释放协程栈空间</span><br><span class="line">    if (m_stack)</span><br><span class="line">    &#123;</span><br><span class="line">        ASSERT(m_state == TERM || m_state == EXCEPT || m_state == INIT);</span><br><span class="line"></span><br><span class="line">        StackAllocator::Dealloc(m_stack, m_stacksize);</span><br><span class="line">    &#125;</span><br><span class="line">    //! 没有协程栈时，说明为主协程，将主协程置空</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        //! 主协程没有运行函数且状态一直为执行</span><br><span class="line">        ASSERT(!m_cb);</span><br><span class="line">        ASSERT(m_state == EXEC);</span><br><span class="line"></span><br><span class="line">        Fiber *cur = t_fiber;</span><br><span class="line">        if (cur == this)</span><br><span class="line">        &#123;</span><br><span class="line">            SetThis(nullptr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    LOG_DEBUG(g_logger) &lt;&lt; &quot;Fiber::~Fiber id=&quot; &lt;&lt; m_id</span><br><span class="line">                        &lt;&lt; &quot; total=&quot; &lt;&lt; s_fiber_count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="协程调度模块"><a href="#协程调度模块" class="headerlink" title="协程调度模块"></a>协程调度模块</h1><h2 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h2></li>
</ol>
<ul>
<li>功能：内部有一个线程池,支持协程在线程池里面切换，封装的是N-M的协程调度器，N个线程，M个携程<h2 id="组件-5"><a href="#组件-5" class="headerlink" title="组件"></a>组件</h2></li>
<li>协程调度器类（Scheduler）<ul>
<li>成员属性<ul>
<li>互斥锁</li>
<li>线程池</li>
<li>待执行的任务队列</li>
<li>调度协程（use_caller为true时有效）</li>
<li>协程调度器名称</li>
<li>以上为公有属性</li>
<li>协程下的线程id数组</li>
<li>线程数量</li>
<li>工作线程数量</li>
<li>空闲线程数量</li>
<li>是否正在停止</li>
<li>是否自动停止</li>
<li>主线程id(use_caller)</li>
</ul>
</li>
<li>成员函数<h2 id="整体逻辑-5"><a href="#整体逻辑-5" class="headerlink" title="整体逻辑"></a>整体逻辑</h2></li>
</ul>
</li>
</ul>
<ol>
<li>主线程创建协程调度器<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Scheduler::Scheduler(size_t threads, bool use_caller, const std::string &amp;name)</span><br><span class="line">        : m_name(name)</span><br><span class="line">    &#123;</span><br><span class="line">        ASSERT(threads &gt; 0);</span><br><span class="line">        //! 若需要主线程（创建该调度器的线程，非线程池的线程）执行任务</span><br><span class="line">        if (use_caller)</span><br><span class="line">        &#123;</span><br><span class="line">            //! 创建线程主协程</span><br><span class="line">            HPS::Fiber::GetThis();</span><br><span class="line">            --threads;</span><br><span class="line"></span><br><span class="line">            ASSERT(GetThis() == nullptr);</span><br><span class="line">            t_scheduler = this;</span><br><span class="line">            //! 回调函数往往通过函数指针来实现，而类的成员函数，多了一个隐含的参数this，</span><br><span class="line">            //! 所以直接赋值给函数指针会引起编译报错。通过bind可以解决此问题</span><br><span class="line">            m_rootFiber.reset(new Fiber(std::bind(&amp;Scheduler::run, this), 0, true));</span><br><span class="line">            HPS::Thread::SetName(m_name);</span><br><span class="line">            //! 线程主协程作为调度协程</span><br><span class="line">            t_scheduler_fiber = m_rootFiber.get();</span><br><span class="line">            m_rootThread = HPS::GetThreadId();</span><br><span class="line">            m_threadIds.push_back(m_rootThread);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            m_rootThread = -1;</span><br><span class="line">        &#125;</span><br><span class="line">        m_threadCount = threads;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li>调度器启动<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void Scheduler::start()</span><br><span class="line">&#123;</span><br><span class="line">    MutexType::Lock lock(m_mutex);</span><br><span class="line">    //! 若调度器正处于停止状态，则无法启动</span><br><span class="line">    if (!m_stopping)</span><br><span class="line">    &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    m_stopping = false;</span><br><span class="line">    ASSERT(m_threads.empty());</span><br><span class="line">    //! 创建线程池</span><br><span class="line">    m_threads.resize(m_threadCount);</span><br><span class="line">    for (size_t i = 0; i &lt; m_threadCount; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        m_threads[i].reset(new Thread(std::bind(&amp;Scheduler::run, this), m_name + &quot;_&quot; + std::to_string(i)));</span><br><span class="line">        m_threadIds.push_back(m_threads[i]-&gt;getId());</span><br><span class="line">    &#125;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
3)调度器执行</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line">void Scheduler::run()</span><br><span class="line">&#123;</span><br><span class="line">    LOG_DEBUG(g_logger) &lt;&lt; m_name &lt;&lt; &quot; run&quot;;</span><br><span class="line">    // set_hook_enable(true);</span><br><span class="line">    //! 设置当前线程的调度器（作用???）</span><br><span class="line">    setThis();</span><br><span class="line">    //! 如果当前线程不是主线程</span><br><span class="line">    if (HPS::GetThreadId() != m_rootThread)</span><br><span class="line">    &#123;</span><br><span class="line">        //! 在该线程上创建调度协程</span><br><span class="line">        t_scheduler_fiber = Fiber::GetThis().get();</span><br><span class="line">    &#125;</span><br><span class="line">    //! 运行空闲方法的协程</span><br><span class="line">    Fiber::ptr idle_fiber(new Fiber(std::bind(&amp;Scheduler::idle, this)));</span><br><span class="line">    //! 执行任务的协程</span><br><span class="line">    Fiber::ptr cb_fiber;</span><br><span class="line"></span><br><span class="line">    Task task;</span><br><span class="line">    while (true)</span><br><span class="line">    &#123;</span><br><span class="line">        task.reset();</span><br><span class="line">        //! 作用（???）</span><br><span class="line">        bool tickle_me = false;</span><br><span class="line">        bool is_active = false;</span><br><span class="line">        &#123;</span><br><span class="line">            MutexType::Lock lock(m_mutex);</span><br><span class="line">            auto it = m_tasks.begin();</span><br><span class="line">            //! 遍历任务队列，</span><br><span class="line">            while (it != m_tasks.end())</span><br><span class="line">            &#123;</span><br><span class="line">                //! 若该任务不能被任意线程执行，或者不是能执行该任务相应的线程</span><br><span class="line">                if (it-&gt;thread != -1 &amp;&amp; it-&gt;thread != HPS::GetThreadId())</span><br><span class="line">                &#123;</span><br><span class="line">                    ++it;</span><br><span class="line">                    tickle_me = true;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                ASSERT(it-&gt;fiber || it-&gt;cb);</span><br><span class="line">                //! 若该任务已经在执行状态</span><br><span class="line">                if (it-&gt;fiber &amp;&amp; it-&gt;fiber-&gt;getState() == Fiber::EXEC)</span><br><span class="line">                &#123;</span><br><span class="line">                    ++it;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                //! 线程取得任务</span><br><span class="line">                task = *it;</span><br><span class="line">                m_tasks.erase(it++);</span><br><span class="line">                ++m_activeThreadCount;</span><br><span class="line">                is_active = true;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            tickle_me |= it != m_tasks.end();</span><br><span class="line">        &#125;</span><br><span class="line">        //! ???</span><br><span class="line">        if (tickle_me)</span><br><span class="line">        &#123;</span><br><span class="line">            tickle();</span><br><span class="line">        &#125;</span><br><span class="line">        //! 取到任务时执行</span><br><span class="line">        if (task.fiber &amp;&amp; (task.fiber-&gt;getState() != Fiber::TERM &amp;&amp; task.fiber-&gt;getState() != Fiber::EXCEPT))</span><br><span class="line">        &#123;</span><br><span class="line">            task.fiber-&gt;call();</span><br><span class="line">            --m_activeThreadCount;</span><br><span class="line"></span><br><span class="line">            if (task.fiber-&gt;getState() == Fiber::READY)</span><br><span class="line">            &#123;</span><br><span class="line">                schedule(task.fiber);</span><br><span class="line">            &#125;</span><br><span class="line">            else if (task.fiber-&gt;getState() != Fiber::TERM &amp;&amp; task.fiber-&gt;getState() != Fiber::EXCEPT)</span><br><span class="line">            &#123;</span><br><span class="line">                task.fiber-&gt;m_state = Fiber::HOLD;</span><br><span class="line">            &#125;</span><br><span class="line">            task.reset();</span><br><span class="line">        &#125;</span><br><span class="line">        else if (task.cb)</span><br><span class="line">        &#123;</span><br><span class="line">            if (cb_fiber)</span><br><span class="line">            &#123;</span><br><span class="line">                cb_fiber-&gt;reset(task.cb);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                cb_fiber.reset(new Fiber(task.cb));</span><br><span class="line">            &#125;</span><br><span class="line">            task.reset();</span><br><span class="line">            cb_fiber-&gt;call();</span><br><span class="line">            --m_activeThreadCount;</span><br><span class="line">            if (cb_fiber-&gt;getState() == Fiber::READY)</span><br><span class="line">            &#123;</span><br><span class="line">                schedule(cb_fiber);</span><br><span class="line">                cb_fiber.reset();</span><br><span class="line">            &#125;</span><br><span class="line">            else if (cb_fiber-&gt;getState() == Fiber::EXCEPT || cb_fiber-&gt;getState() == Fiber::TERM)</span><br><span class="line">            &#123;</span><br><span class="line">                cb_fiber-&gt;reset(nullptr);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123; // if(cb_fiber-&gt;getState() != Fiber::TERM) &#123;</span><br><span class="line">                cb_fiber-&gt;m_state = Fiber::HOLD;</span><br><span class="line">                cb_fiber.reset();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //! 没有取到时，陷入空闲方法</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            if (is_active)</span><br><span class="line">            &#123;</span><br><span class="line">                --m_activeThreadCount;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if (idle_fiber-&gt;getState() == Fiber::TERM)</span><br><span class="line">            &#123;</span><br><span class="line">                LOG_INFO(g_logger) &lt;&lt; &quot;idle fiber term&quot;;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ++m_idleThreadCount;</span><br><span class="line">            idle_fiber-&gt;call();</span><br><span class="line">            --m_idleThreadCount;</span><br><span class="line">            if (idle_fiber-&gt;getState() != Fiber::TERM &amp;&amp; idle_fiber-&gt;getState() != Fiber::EXCEPT)</span><br><span class="line">            &#123;</span><br><span class="line">                idle_fiber-&gt;m_state = Fiber::HOLD;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>主线程将调度器停止</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">void Scheduler::stop()</span><br><span class="line">&#123;</span><br><span class="line">    m_autoStop = true;</span><br><span class="line">    //! 当只有主线程执行任务时</span><br><span class="line">    if (m_rootFiber &amp;&amp; m_threadCount == 0 &amp;&amp; (m_rootFiber-&gt;getState() == Fiber::TERM || m_rootFiber-&gt;getState() == Fiber::INIT))</span><br><span class="line">    &#123;</span><br><span class="line">        LOG_INFO(g_logger) &lt;&lt; this &lt;&lt; &quot; stopped&quot;;</span><br><span class="line">        m_stopping = true;</span><br><span class="line"></span><br><span class="line">        if (stopping())</span><br><span class="line">        &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // bool exit_on_this_fiber = false;</span><br><span class="line">    //! 主线程参与执行任务</span><br><span class="line">    if (m_rootThread != -1)</span><br><span class="line">    &#123;</span><br><span class="line">        ASSERT(GetThis() == this);</span><br><span class="line">    &#125;</span><br><span class="line">    //! 主线程不参与执行任务</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        //! 其他线程不得停止调度器</span><br><span class="line">        ASSERT(GetThis() != this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_stopping = true;</span><br><span class="line">    for (size_t i = 0; i &lt; m_threadCount; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        tickle();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (m_rootFiber)</span><br><span class="line">    &#123;</span><br><span class="line">        tickle();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (m_rootFiber)</span><br><span class="line">    &#123;</span><br><span class="line">        // while(!stopping()) &#123;</span><br><span class="line">        //     if(m_rootFiber-&gt;getState() == Fiber::TERM</span><br><span class="line">        //             || m_rootFiber-&gt;getState() == Fiber::EXCEPT) &#123;</span><br><span class="line">        //         m_rootFiber.reset(new Fiber(std::bind(&amp;Scheduler::run, this), 0, true));</span><br><span class="line">        //         LOG_INFO(g_logger) &lt;&lt; &quot; root fiber is term, reset&quot;;</span><br><span class="line">        //         t_fiber = m_rootFiber.get();</span><br><span class="line">        //     &#125;</span><br><span class="line">        //     m_rootFiber-&gt;call();</span><br><span class="line">        // &#125;</span><br><span class="line">        if (!stopping())</span><br><span class="line">        &#123;</span><br><span class="line">            //! 主线程执行任务</span><br><span class="line">            m_rootFiber-&gt;call();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;Thread::ptr&gt; thrs;</span><br><span class="line">    &#123;</span><br><span class="line">        MutexType::Lock lock(m_mutex);</span><br><span class="line">        thrs.swap(m_threads);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (auto &amp;i : thrs)</span><br><span class="line">    &#123;</span><br><span class="line">        i-&gt;join();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//! 空闲方法，</span><br><span class="line">void Scheduler::idle()</span><br><span class="line">&#123;</span><br><span class="line">    LOG_INFO(g_logger) &lt;&lt; &quot;idle&quot;;</span><br><span class="line">    //! 直到调度器可以终止</span><br><span class="line">    while (!stopping())</span><br><span class="line">    &#123;</span><br><span class="line">        //! 空闲协程和调度协程在此切入切出</span><br><span class="line">        HPS::Fiber::YieldToHold();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>调度器销毁</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Scheduler::~Scheduler()</span><br><span class="line">    &#123;</span><br><span class="line">        ASSERT(m_stopping);</span><br><span class="line">        if (GetThis() == this)</span><br><span class="line">        &#123;</span><br><span class="line">            t_scheduler = nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">static HPS::Logger::ptr g_logger = LOG_ROOT();</span><br><span class="line"></span><br><span class="line">void test_fiber() &#123;</span><br><span class="line">    static int s_count = 5;</span><br><span class="line">    LOG_INFO(g_logger) &lt;&lt; &quot;test in fiber s_count=&quot; &lt;&lt; s_count;</span><br><span class="line"></span><br><span class="line">    sleep(1);</span><br><span class="line">    if(--s_count &gt;= 0) &#123;</span><br><span class="line">        HPS::Scheduler::GetThis()-&gt;schedule(&amp;test_fiber, HPS::GetThreadId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char** argv) &#123;</span><br><span class="line">    LOG_INFO(g_logger) &lt;&lt; &quot;main&quot;;</span><br><span class="line">    HPS::Scheduler sc(1, false, &quot;test&quot;);</span><br><span class="line">    sc.start();</span><br><span class="line">    sleep(2);</span><br><span class="line">    LOG_INFO(g_logger) &lt;&lt; &quot;schedule&quot;;</span><br><span class="line">    sc.schedule(&amp;test_fiber);</span><br><span class="line">    sc.stop();</span><br><span class="line">    LOG_INFO(g_logger) &lt;&lt; &quot;over&quot;;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="定时器模块"><a href="#定时器模块" class="headerlink" title="定时器模块"></a>定时器模块</h1><h2 id="概述-7"><a href="#概述-7" class="headerlink" title="概述"></a>概述</h2><ul>
<li><p>功能：</p>
<h2 id="组件-6"><a href="#组件-6" class="headerlink" title="组件"></a>组件</h2></li>
<li><p>定时器类（Timer）</p>
<ul>
<li>成员属性<ul>
<li>是否循环定时器</li>
<li>执行周期</li>
<li>精确的执行时间</li>
<li>回调函数</li>
<li>定时器管理器</li>
</ul>
</li>
<li>成员函数<ul>
<li>创建、销毁定时器</li>
<li>取消定时器</li>
<li>刷新设置定时器的执行时间</li>
<li>重置定时器时间</li>
</ul>
</li>
</ul>
</li>
<li><p>定时器管理器类(TimerManager)</p>
<ul>
<li>成员属性<ul>
<li>互斥量</li>
<li>定时器集合<ul>
<li>按照执行时间先后排序</li>
</ul>
</li>
<li>是否触发onTimerInsertedAtFront</li>
<li>上次执行时间</li>
</ul>
</li>
<li>成员函数<ul>
<li>添加定时器</li>
<li>添加条件定时器</li>
<li>到最近一个定时器执行的时间间隔(毫秒)</li>
<li>获取需要执行的定时器的回调函数列表</li>
<li>是否有定时器</li>
<li>当有新的定时器插入到定时器的首部,执行该函数</li>
<li>将定时器添加到管理器中</li>
<li>检测服务器时间是否被调后了</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="整体逻辑-6"><a href="#整体逻辑-6" class="headerlink" title="整体逻辑"></a>整体逻辑</h2><p>1)创建定时器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Timer::Timer(uint64_t ms, std::function&lt;void()&gt; cb,</span><br><span class="line">                 bool recurring, TimerManager *manager)</span><br><span class="line">        : m_recurring(recurring), m_ms(ms), m_cb(cb), m_manager(manager)</span><br><span class="line">    &#123;</span><br><span class="line">        m_next = HPS::GetCurrentMS() + m_ms;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">Timer::Timer(uint64_t next)</span><br><span class="line">    : m_next(next)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>创建定时器管理器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TimerManager::TimerManager()</span><br><span class="line">&#123;</span><br><span class="line">    m_previouseTime = HPS::GetCurrentMS();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加定时器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Timer::ptr TimerManager::addTimer(uint64_t ms, std::function&lt;void()&gt; cb, bool recurring)</span><br><span class="line">&#123;</span><br><span class="line">    Timer::ptr timer(new Timer(ms, cb, recurring, this));</span><br><span class="line">    RWMutexType::WriteLock lock(m_mutex);</span><br><span class="line">    addTimer(timer, lock);</span><br><span class="line">    return timer;</span><br><span class="line">&#125;</span><br><span class="line">void TimerManager::addTimer(Timer::ptr val, RWMutexType::WriteLock &amp;lock)</span><br><span class="line">&#123;</span><br><span class="line">    auto it = m_timers.insert(val).first;</span><br><span class="line">    //! 若插入的定时器为集合头部（即为最早执行的定时器），且没有触发onTimerInsertedAtFront</span><br><span class="line">    bool at_front = (it == m_timers.begin()) &amp;&amp; !m_tickled;</span><br><span class="line">    if (at_front)</span><br><span class="line">    &#123;</span><br><span class="line">        m_tickled = true;</span><br><span class="line">    &#125;</span><br><span class="line">    lock.unlock();</span><br><span class="line"></span><br><span class="line">    if (at_front)</span><br><span class="line">    &#123;</span><br><span class="line">        onTimerInsertedAtFront();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取需要执行的定时器的回调函数列表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">void TimerManager::listExpiredCb(std::vector&lt;std::function&lt;void()&gt;&gt; &amp;cbs)</span><br><span class="line">&#123;</span><br><span class="line">    uint64_t now_ms = HPS::GetCurrentMS();</span><br><span class="line">    //! 在定时器集合中提取已经失效的定时器（过期的）</span><br><span class="line">    std::vector&lt;Timer::ptr&gt; expired;</span><br><span class="line">    &#123;</span><br><span class="line">        RWMutexType::ReadLock lock(m_mutex);</span><br><span class="line">        if (m_timers.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    RWMutexType::WriteLock lock(m_mutex);</span><br><span class="line">    if (m_timers.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //! 检测管理器执行时间是否被调后了,并重置管理器执行时间</span><br><span class="line">    bool rollover = detectClockRollover(now_ms);</span><br><span class="line">    //! 若管理器执行时间没有被调后且最近要执行的定时器时间晚于当前时间</span><br><span class="line">    if (!rollover &amp;&amp; ((*m_timers.begin())-&gt;m_next &gt; now_ms))</span><br><span class="line">    &#123;</span><br><span class="line">        //! 不存在过期的定时器</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Timer::ptr now_timer(new Timer(now_ms));</span><br><span class="line">    //! 若管理器执行时间已调后，则所有定时器全部过期（需要执行）</span><br><span class="line">    //! 否则将所有精确执行时间为当前时间的定时器放入过期定时器数组</span><br><span class="line">    auto it = rollover ? m_timers.end() : m_timers.lower_bound(now_timer);</span><br><span class="line">    while (it != m_timers.end() &amp;&amp; (*it)-&gt;m_next == now_ms)</span><br><span class="line">    &#123;</span><br><span class="line">        ++it;</span><br><span class="line">    &#125;</span><br><span class="line">    expired.insert(expired.begin(), m_timers.begin(), it);</span><br><span class="line">    m_timers.erase(m_timers.begin(), it);</span><br><span class="line">    cbs.reserve(expired.size());</span><br><span class="line"></span><br><span class="line">    for (auto &amp;timer : expired)</span><br><span class="line">    &#123;</span><br><span class="line">        cbs.push_back(timer-&gt;m_cb);</span><br><span class="line">        if (timer-&gt;m_recurring)</span><br><span class="line">        &#123;</span><br><span class="line">            //! 若为循环定时器，则将定时器重新加入到定时器集合</span><br><span class="line">            timer-&gt;m_next = now_ms + timer-&gt;m_ms;</span><br><span class="line">            m_timers.insert(timer);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            timer-&gt;m_cb = nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>执行定时器管理器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;std::function&lt;void()&gt; &gt; cbs;</span><br><span class="line">listExpiredCb(cbs);</span><br><span class="line">//! 执行定时器管理器</span><br><span class="line">if(!cbs.empty()) &#123;</span><br><span class="line">    //LOG_DEBUG(g_logger) &lt;&lt; &quot;on timer cbs.size=&quot; &lt;&lt; cbs.size();</span><br><span class="line">    schedule(cbs.begin(), cbs.end());</span><br><span class="line">    cbs.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>6)销毁定时器管理器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TimerManager::~TimerManager()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h2><h1 id="IO协程调度模块"><a href="#IO协程调度模块" class="headerlink" title="IO协程调度模块"></a>IO协程调度模块</h1><h2 id="概述-8"><a href="#概述-8" class="headerlink" title="概述"></a>概述</h2><ul>
<li>功能<h2 id="组件-7"><a href="#组件-7" class="headerlink" title="组件"></a>组件</h2></li>
<li>基于Epoll的IO协程调度器（IOManager）<ul>
<li>成员属性<ul>
<li>epoll 文件句柄</li>
<li>pipe 文件句柄</li>
<li>当前等待执行的事件数量</li>
<li>IOManager的Mutex</li>
<li>socket事件上下文的容器</li>
<li>IO事件</li>
<li>Socket事件管理结构<ul>
<li>成员属性<ul>
<li>事件上下文：事件执行的调度器、协程、回调函数</li>
<li>读、写事件上下文</li>
<li>事件关联的句柄</li>
<li>当前的事件</li>
<li>事件的Mutex</li>
</ul>
</li>
<li>成员方法<ul>
<li>获取事件上下文</li>
<li>重置事件上下文</li>
<li>触发事件</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>成员函数<ul>
<li>创建、销毁IO协程调度</li>
<li>添加、删除、取消、取消所有事件</li>
<li>返回当前的IOManager（静态）</li>
<li>重置socket句柄上下文的容器大小</li>
<li>判断是否可以停止</li>
<li>继承并重写协程调度器的函数：tickle、stopping、idle、onTimerInsertedAtFront</li>
<li>重置socket句柄上下文的容器大小</li>
<li>判断是否可以停止<h2 id="整体逻辑-7"><a href="#整体逻辑-7" class="headerlink" title="整体逻辑"></a>整体逻辑</h2></li>
</ul>
</li>
</ul>
</li>
</ul>
<ol>
<li><p>创建协程调度器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">IOManager::IOManager(size_t threads, bool use_caller, const std::string &amp;name)</span><br><span class="line">        : Scheduler(threads, use_caller, name)</span><br><span class="line">    &#123;</span><br><span class="line">        //! 创建epoll实例</span><br><span class="line">        m_epfd = epoll_create(5000);</span><br><span class="line">        ASSERT(m_epfd &gt; 0);</span><br><span class="line">        //! 创建读写管道，作用???</span><br><span class="line">        int rt = pipe(m_tickleFds);</span><br><span class="line">        ASSERT(!rt);</span><br><span class="line">        //! 向读管道添加epoll读事件，边缘触发</span><br><span class="line">        epoll_event event;</span><br><span class="line">        memset(&amp;event, 0, sizeof(epoll_event));</span><br><span class="line">        event.events = EPOLLIN | EPOLLET;</span><br><span class="line">        event.data.fd = m_tickleFds[0];</span><br><span class="line">        //! 设置(F_SETFL)读管道为非阻塞(O_NONBLOCK)</span><br><span class="line">        rt = fcntl(m_tickleFds[0], F_SETFL, O_NONBLOCK);</span><br><span class="line">        ASSERT(!rt);</span><br><span class="line">        //! 向epoll实例添加epoll事件</span><br><span class="line">        rt = epoll_ctl(m_epfd, EPOLL_CTL_ADD, m_tickleFds[0], &amp;event);</span><br><span class="line">        ASSERT(!rt);</span><br><span class="line">        //! 设定socket事件集合容量</span><br><span class="line">        contextResize(32);</span><br><span class="line">        //! 启动协程调度器</span><br><span class="line">        start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>线程在空闲方法（协程）中，等待IO事件</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line">void IOManager::idle()</span><br><span class="line">&#123;</span><br><span class="line">    LOG_DEBUG(g_logger) &lt;&lt; &quot;idle&quot;;</span><br><span class="line">    const uint64_t MAX_EVNETS = 256;</span><br><span class="line">    //! 创建epoll事件数组，使用自定义析构函数释放数组空间</span><br><span class="line">    epoll_event *events = new epoll_event[MAX_EVNETS]();</span><br><span class="line">    std::shared_ptr&lt;epoll_event&gt; shared_events(events, [](epoll_event *ptr)</span><br><span class="line">                                               &#123; delete[] ptr; &#125;);</span><br><span class="line"></span><br><span class="line">    while (true)</span><br><span class="line">    &#123;</span><br><span class="line">        uint64_t next_timeout = 0;</span><br><span class="line">        //! 调度器可终止时，跳出循环</span><br><span class="line">        if (UNLIKELY(stopping(next_timeout)))</span><br><span class="line">        &#123;</span><br><span class="line">            LOG_INFO(g_logger) &lt;&lt; &quot;name=&quot; &lt;&lt; getName()</span><br><span class="line">                               &lt;&lt; &quot; idle stopping exit&quot;;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int rt = 0;</span><br><span class="line">        do</span><br><span class="line">        &#123;</span><br><span class="line">            //! epoll_wait最长等待时间，超过此事件epoll_wait不再等待，继续执行后继代码</span><br><span class="line">            static const int MAX_TIMEOUT = 3000;</span><br><span class="line">            if (next_timeout != ~0ull)</span><br><span class="line">            &#123;</span><br><span class="line">                next_timeout = (int)next_timeout &gt; MAX_TIMEOUT</span><br><span class="line">                                   ? MAX_TIMEOUT</span><br><span class="line">                                   : next_timeout;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                next_timeout = MAX_TIMEOUT;</span><br><span class="line">            &#125;</span><br><span class="line">            rt = epoll_wait(m_epfd, events, MAX_EVNETS, (int)next_timeout);</span><br><span class="line">            if (rt &lt; 0 &amp;&amp; errno == EINTR)</span><br><span class="line">            &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; while (true);</span><br><span class="line"></span><br><span class="line">        //! 获取需要执行的定时器的回调函数列表</span><br><span class="line">        std::vector&lt;std::function&lt;void()&gt;&gt; cbs;</span><br><span class="line">        listExpiredCb(cbs);</span><br><span class="line">        //! 执行定时器管理器</span><br><span class="line">        if (!cbs.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            // LOG_DEBUG(g_logger) &lt;&lt; &quot;on timer cbs.size=&quot; &lt;&lt; cbs.size();</span><br><span class="line">            schedule(cbs.begin(), cbs.end());</span><br><span class="line">            cbs.clear();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // if(UNLIKELY(rt == MAX_EVNETS)) &#123;</span><br><span class="line">        //     LOG_INFO(g_logger) &lt;&lt; &quot;epoll wait events=&quot; &lt;&lt; rt;</span><br><span class="line">        // &#125;</span><br><span class="line">        //! 遍历epoll事件数组</span><br><span class="line">        for (int i = 0; i &lt; rt; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            epoll_event &amp;event = events[i];</span><br><span class="line">            if (event.data.fd == m_tickleFds[0])</span><br><span class="line">            &#123;</span><br><span class="line">                uint8_t dummy[256];</span><br><span class="line">                while (read(m_tickleFds[0], dummy, sizeof(dummy)) &gt; 0)</span><br><span class="line">                    ;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            //! 提取epoll事件以及socket文件句柄上的读写事件</span><br><span class="line">            FdContext *fd_ctx = (FdContext *)event.data.ptr;</span><br><span class="line">            FdContext::MutexType::Lock lock(fd_ctx-&gt;mutex);</span><br><span class="line">            if (event.events &amp; (EPOLLERR | EPOLLHUP))</span><br><span class="line">            &#123;</span><br><span class="line">                event.events |= (EPOLLIN | EPOLLOUT) &amp; fd_ctx-&gt;events;</span><br><span class="line">            &#125;</span><br><span class="line">            int real_events = NONE;</span><br><span class="line">            if (event.events &amp; EPOLLIN)</span><br><span class="line">            &#123;</span><br><span class="line">                real_events |= READ;</span><br><span class="line">            &#125;</span><br><span class="line">            if (event.events &amp; EPOLLOUT)</span><br><span class="line">            &#123;</span><br><span class="line">                real_events |= WRITE;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if ((fd_ctx-&gt;events &amp; real_events) == NONE)</span><br><span class="line">            &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            int left_events = (fd_ctx-&gt;events &amp; ~real_events);</span><br><span class="line">            int op = left_events ? EPOLL_CTL_MOD : EPOLL_CTL_DEL;</span><br><span class="line">            event.events = EPOLLET | left_events;</span><br><span class="line"></span><br><span class="line">            int rt2 = epoll_ctl(m_epfd, op, fd_ctx-&gt;fd, &amp;event);</span><br><span class="line">            if (rt2)</span><br><span class="line">            &#123;</span><br><span class="line">                LOG_ERROR(g_logger) &lt;&lt; &quot;epoll_ctl(&quot; &lt;&lt; m_epfd &lt;&lt; &quot;, &quot;</span><br><span class="line">                                    &lt;&lt; (EpollCtlOp)op &lt;&lt; &quot;, &quot; &lt;&lt; fd_ctx-&gt;fd &lt;&lt; &quot;, &quot; &lt;&lt; (EPOLL_EVENTS)event.events &lt;&lt; &quot;):&quot;</span><br><span class="line">                                    &lt;&lt; rt2 &lt;&lt; &quot; (&quot; &lt;&lt; errno &lt;&lt; &quot;) (&quot; &lt;&lt; strerror(errno) &lt;&lt; &quot;)&quot;;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            //! 触发socket句柄上的读写事件</span><br><span class="line">            // LOG_INFO(g_logger) &lt;&lt; &quot; fd=&quot; &lt;&lt; fd_ctx-&gt;fd &lt;&lt; &quot; events=&quot; &lt;&lt; fd_ctx-&gt;events</span><br><span class="line">            //                          &lt;&lt; &quot; real_events=&quot; &lt;&lt; real_events;</span><br><span class="line">            if (real_events &amp; READ)</span><br><span class="line">            &#123;</span><br><span class="line">                fd_ctx-&gt;triggerEvent(READ);</span><br><span class="line">                --m_pendingEventCount;</span><br><span class="line">            &#125;</span><br><span class="line">            if (real_events &amp; WRITE)</span><br><span class="line">            &#123;</span><br><span class="line">                fd_ctx-&gt;triggerEvent(WRITE);</span><br><span class="line">                --m_pendingEventCount;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Fiber::ptr cur = Fiber::GetThis();</span><br><span class="line">        auto raw_ptr = cur.get();</span><br><span class="line">        cur.reset();</span><br><span class="line"></span><br><span class="line">        raw_ptr-&gt;back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//! 触发事件</span><br><span class="line">void IOManager::FdContext::triggerEvent(IOManager::Event event)</span><br><span class="line">&#123;</span><br><span class="line">    // LOG_INFO(g_logger) &lt;&lt; &quot;fd=&quot; &lt;&lt; fd</span><br><span class="line">    //     &lt;&lt; &quot; triggerEvent event=&quot; &lt;&lt; event</span><br><span class="line">    //     &lt;&lt; &quot; events=&quot; &lt;&lt; events;</span><br><span class="line">    ASSERT(events &amp; event);</span><br><span class="line">    // if(UNLIKELY(!(event &amp; event))) &#123;</span><br><span class="line">    //     return;</span><br><span class="line">    // &#125;</span><br><span class="line">    events = (Event)(events &amp; ~event);</span><br><span class="line">    EventContext &amp;ctx = getContext(event);</span><br><span class="line">    if (ctx.cb)</span><br><span class="line">    &#123;</span><br><span class="line">        ctx.scheduler-&gt;schedule(&amp;ctx.cb);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        ctx.scheduler-&gt;schedule(&amp;ctx.fiber);</span><br><span class="line">    &#125;</span><br><span class="line">    ctx.scheduler = nullptr;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>添加IO任务，建立TCP连接，创建socket事件上下文</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//! 添加IO任务</span><br><span class="line">iom.schedule(&amp;test_fiber);</span><br><span class="line"></span><br><span class="line">//! 创建socket事件，建立TCP连接</span><br><span class="line">LOG_INFO(g_logger) &lt;&lt; &quot;test_fiber sock=&quot; &lt;&lt; sock;</span><br><span class="line">sock = socket(AF_INET, SOCK_STREAM, 0);</span><br><span class="line">fcntl(sock, F_SETFL, O_NONBLOCK);</span><br><span class="line">sockaddr_in addr;</span><br><span class="line">memset(&amp;addr, 0, sizeof(addr));</span><br><span class="line">addr.sin_family = AF_INET;</span><br><span class="line">addr.sin_port = htons(80);</span><br><span class="line">inet_pton(AF_INET, &quot;115.239.210.27&quot;, &amp;addr.sin_addr.s_addr);</span><br><span class="line"></span><br><span class="line">if (!connect(sock, (const sockaddr *)&amp;addr, sizeof(addr)))</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">else if (errno == EINPROGRESS)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>向socket上下文添加IO事件上下文</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">int IOManager::addEvent(int fd, Event event, std::function&lt;void()&gt; cb)</span><br><span class="line">&#123;</span><br><span class="line">    //! 扩充socket事件句柄集合容量</span><br><span class="line">    FdContext *fd_ctx = nullptr;</span><br><span class="line">    RWMutexType::ReadLock lock(m_mutex);</span><br><span class="line">    if ((int)m_fdContexts.size() &gt; fd)</span><br><span class="line">    &#123;</span><br><span class="line">        fd_ctx = m_fdContexts[fd];</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">        RWMutexType::WriteLock lock2(m_mutex);</span><br><span class="line">        contextResize(fd * 1.5);</span><br><span class="line">        fd_ctx = m_fdContexts[fd];</span><br><span class="line">    &#125;</span><br><span class="line">    FdContext::MutexType::Lock lock2(fd_ctx-&gt;mutex);</span><br><span class="line">    if (UNLIKELY(fd_ctx-&gt;events &amp; event))</span><br><span class="line">    &#123;</span><br><span class="line">        LOG_ERROR(g_logger) &lt;&lt; &quot;addEvent assert fd=&quot; &lt;&lt; fd</span><br><span class="line">                            &lt;&lt; &quot; event=&quot; &lt;&lt; (EPOLL_EVENTS)event</span><br><span class="line">                            &lt;&lt; &quot; fd_ctx.event=&quot; &lt;&lt; (EPOLL_EVENTS)fd_ctx-&gt;events;</span><br><span class="line">        ASSERT(!(fd_ctx-&gt;events &amp; event));</span><br><span class="line">    &#125;</span><br><span class="line">    //! 向epoll实例添加epoll读写事件</span><br><span class="line">    int op = fd_ctx-&gt;events ? EPOLL_CTL_MOD : EPOLL_CTL_ADD;</span><br><span class="line">    epoll_event epevent;</span><br><span class="line">    epevent.events = EPOLLET | fd_ctx-&gt;events | event;</span><br><span class="line">    epevent.data.ptr = fd_ctx;</span><br><span class="line"></span><br><span class="line">    int rt = epoll_ctl(m_epfd, op, fd, &amp;epevent);</span><br><span class="line">    if (rt)</span><br><span class="line">    &#123;</span><br><span class="line">        LOG_ERROR(g_logger) &lt;&lt; &quot;epoll_ctl(&quot; &lt;&lt; m_epfd &lt;&lt; &quot;, &quot;</span><br><span class="line">                            &lt;&lt; (EpollCtlOp)op &lt;&lt; &quot;, &quot; &lt;&lt; fd &lt;&lt; &quot;, &quot; &lt;&lt; (EPOLL_EVENTS)epevent.events &lt;&lt; &quot;):&quot;</span><br><span class="line">                            &lt;&lt; rt &lt;&lt; &quot; (&quot; &lt;&lt; errno &lt;&lt; &quot;) (&quot; &lt;&lt; strerror(errno) &lt;&lt; &quot;) fd_ctx-&gt;events=&quot;</span><br><span class="line">                            &lt;&lt; (EPOLL_EVENTS)fd_ctx-&gt;events;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    //! 待处理的读写事件增加</span><br><span class="line">    ++m_pendingEventCount;</span><br><span class="line">    //! 初始化事件上下文</span><br><span class="line">    fd_ctx-&gt;events = (Event)(fd_ctx-&gt;events | event);</span><br><span class="line">    FdContext::EventContext &amp;event_ctx = fd_ctx-&gt;getContext(event);</span><br><span class="line">    ASSERT(!event_ctx.scheduler &amp;&amp; !event_ctx.fiber &amp;&amp; !event_ctx.cb);</span><br><span class="line"></span><br><span class="line">    event_ctx.scheduler = Scheduler::GetThis();</span><br><span class="line">    if (cb)</span><br><span class="line">    &#123;</span><br><span class="line">        event_ctx.cb.swap(cb);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        event_ctx.fiber = Fiber::GetThis();</span><br><span class="line">        ASSERT2(event_ctx.fiber-&gt;getState() == Fiber::EXEC, &quot;state=&quot; &lt;&lt; event_ctx.fiber-&gt;getState());</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>停止并销毁IO协程调度器<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">IOManager::~IOManager()</span><br><span class="line">&#123;</span><br><span class="line">    stop();</span><br><span class="line">    close(m_epfd);</span><br><span class="line">    close(m_tickleFds[0]);</span><br><span class="line">    close(m_tickleFds[1]);</span><br><span class="line"></span><br><span class="line">    for (size_t i = 0; i &lt; m_fdContexts.size(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        if (m_fdContexts[i])</span><br><span class="line">        &#123;</span><br><span class="line">            delete m_fdContexts[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>总结：<ul>
<li>首先向调度器添加IO任务（函数或协程），IO任务中会创建socket句柄，向socket事件上下文添加读写事件</li>
<li>调度器中线程池的各线程均陷入空闲协程（idle_fiber），在epoll_wait中等待读写事件的到来</li>
<li>当epoll实例检测到存在读写事件时，线程跳出空闲协程返回调度协程</li>
<li>在调度协程中寻找线程相对应的IO任务，取得后陷入任务协程（task_fiber）执行任务</li>
<li>任务执行完后，回到调度协程循环执行以上流程<h2 id="测试-2"><a href="#测试-2" class="headerlink" title="测试"></a>测试</h2></li>
</ul>
</li>
</ul>
<h1 id="文件句柄管理模块"><a href="#文件句柄管理模块" class="headerlink" title="文件句柄管理模块"></a>文件句柄管理模块</h1><h2 id="概述-9"><a href="#概述-9" class="headerlink" title="概述"></a>概述</h2><ul>
<li><p>功能</p>
<ul>
<li>管理文件句柄类型(是否socket)，是否阻塞，是否关闭，读&#x2F;写超时时间<h2 id="组件-8"><a href="#组件-8" class="headerlink" title="组件"></a>组件</h2></li>
</ul>
</li>
<li><p>文件句柄上下文类</p>
<ul>
<li>成员属性<ul>
<li>是否初始化</li>
<li>是否socket</li>
<li>是否hook非阻塞</li>
<li>是否用户主动设置非阻塞</li>
<li>是否关闭</li>
<li>文件句柄</li>
<li>读超时时间毫秒</li>
<li>写超时时间毫秒</li>
</ul>
</li>
<li>成员函数<ul>
<li>初始化</li>
<li>是否初始化完成</li>
<li>是否socket</li>
<li>是否已关闭</li>
<li>设置用户主动设置非阻塞</li>
<li>获取是否用户主动设置的非阻塞</li>
<li>设置系统非阻塞</li>
<li>获取系统非阻塞</li>
<li>设置超时时间</li>
<li>获取超时时间</li>
</ul>
</li>
</ul>
</li>
<li><p>文件句柄管理类</p>
<ul>
<li>成员属性<ul>
<li>读写锁</li>
<li>文件句柄集合</li>
</ul>
</li>
<li>成员函数<ul>
<li>获取&#x2F;创建文件句柄类FdCtx</li>
<li>删除文件句柄类</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="整体逻辑-8"><a href="#整体逻辑-8" class="headerlink" title="整体逻辑"></a>整体逻辑</h2><h2 id="测试-3"><a href="#测试-3" class="headerlink" title="测试"></a>测试</h2><h1 id="HOOK模块"><a href="#HOOK模块" class="headerlink" title="HOOK模块"></a>HOOK模块</h1><h2 id="概述-10"><a href="#概述-10" class="headerlink" title="概述"></a>概述</h2><ul>
<li>功能：<ul>
<li>Hook，就是在一个已有的方法上加入一些钩子，使得在该方法执行前或执行后另在做一些额外的处理</li>
<li>作用<ul>
<li>事实上如果一个项目在设计架构时考虑的足够充分，模块抽象的足够合理，设计之初为以后的扩展预留了足够的接口，那么我们完全可以不需要Hook技巧。</li>
<li>但恰恰架构人员在项目设计之初往往没办法想的足够的深远，使得后续在扩展时面临重构的痛苦，这时Hook技巧似乎可以为我们带来一记缓兵之计，通过对旧的架构进行加钩子来满足新的扩展需求。</li>
</ul>
</li>
<li>钩子函数，顾名思义，就是把我们自己实现的hook函数在某一时刻挂接到目标挂载点上。</li>
<li></li>
</ul>
</li>
</ul>
<h2 id="组件-9"><a href="#组件-9" class="headerlink" title="组件"></a>组件</h2><ul>
<li>某某类<ul>
<li>成员属性</li>
<li>成员函数<h2 id="整体逻辑-9"><a href="#整体逻辑-9" class="headerlink" title="整体逻辑"></a>整体逻辑</h2></li>
</ul>
</li>
</ul>
<ol>
<li><p>引入外部C库函数，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// read</span><br><span class="line">typedef ssize_t (*read_fun)(int fd, void *buf, size_t count);</span><br><span class="line">extern read_fun read_f;</span><br></pre></td></tr></table></figure>
</li>
<li><p>宏定义批量“钩”C库函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#define HOOK_FUN(XX) \</span><br><span class="line">    XX(sleep)        \</span><br><span class="line">    XX(usleep)       \</span><br><span class="line">    XX(nanosleep)    \</span><br><span class="line">    XX(socket)       \</span><br><span class="line">    XX(connect)      \</span><br><span class="line">    XX(accept)       \</span><br><span class="line">    XX(read)         \</span><br><span class="line">    XX(readv)        \</span><br><span class="line">    XX(recv)         \</span><br><span class="line">    XX(recvfrom)     \</span><br><span class="line">    XX(recvmsg)      \</span><br><span class="line">    XX(write)        \</span><br><span class="line">    XX(writev)       \</span><br><span class="line">    XX(send)         \</span><br><span class="line">    XX(sendto)       \</span><br><span class="line">    XX(sendmsg)      \</span><br><span class="line">    XX(close)        \</span><br><span class="line">    XX(fcntl)        \</span><br><span class="line">    XX(ioctl)        \</span><br><span class="line">    XX(getsockopt)   \</span><br><span class="line">    XX(setsockopt)</span><br></pre></td></tr></table></figure>

</li>
<li><p>初始化HOOK</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void hook_init()</span><br><span class="line">    &#123;</span><br><span class="line">        static bool is_inited = false;</span><br><span class="line">        if (is_inited)</span><br><span class="line">        &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //! dlsym根据动态链接库操作句柄与符号，返回符号对应的地址，</span><br><span class="line">        //! 不但可以获取函数地址，可以获取变量地址。</span><br><span class="line">        //! 钩住!</span><br><span class="line">#define XX(name) name##_f = (name##_fun)dlsym(RTLD_NEXT, #name);</span><br><span class="line">        HOOK_FUN(XX);</span><br><span class="line">#undef XX</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>HOOK初始化结构体</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct _HookIniter</span><br><span class="line">    &#123;</span><br><span class="line">        _HookIniter()</span><br><span class="line">        &#123;</span><br><span class="line">            hook_init();</span><br><span class="line">            s_connect_timeout = g_tcp_connect_timeout-&gt;getValue();</span><br><span class="line"></span><br><span class="line">            g_tcp_connect_timeout-&gt;addListener([](const int &amp;old_value, const int &amp;new_value)</span><br><span class="line">                                               &#123;</span><br><span class="line">                LOG_INFO(g_logger) &lt;&lt; &quot;tcp connect timeout changed from &quot;</span><br><span class="line">                                         &lt;&lt; old_value &lt;&lt; &quot; to &quot; &lt;&lt; new_value;</span><br><span class="line">                s_connect_timeout = new_value; &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>自动创建HOOK初始化结构体默认构造函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static _HookIniter s_hook_initer;</span><br></pre></td></tr></table></figure>
</li>
<li><p>自定义IO</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename OriginFun, typename... Args&gt;</span><br><span class="line">static ssize_t do_io(int fd, OriginFun fun, const char *hook_fun_name,</span><br><span class="line">                     uint32_t event, int timeout_so, Args &amp;&amp;...args)</span><br><span class="line">&#123;</span><br><span class="line">    //! 若“不钩”则直接调用内部C库函数</span><br><span class="line">    if (!HPS::t_hook_enable)</span><br><span class="line">    &#123;</span><br><span class="line">        return fun(fd, std::forward&lt;Args&gt;(args)...);</span><br><span class="line">    &#125;</span><br><span class="line">    //! 向句柄管理器添加并获取文件句柄管理对象</span><br><span class="line">    HPS::FdCtx::ptr ctx = HPS::FdMgr::GetInstance()-&gt;get(fd);</span><br><span class="line">    if (!ctx)</span><br><span class="line">    &#123;</span><br><span class="line">        return fun(fd, std::forward&lt;Args&gt;(args)...);</span><br><span class="line">    &#125;</span><br><span class="line">    //! 文件若关闭</span><br><span class="line">    if (ctx-&gt;isClose())</span><br><span class="line">    &#123;</span><br><span class="line">        errno = EBADF;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    //! 不是socket句柄或用户主动设为阻塞</span><br><span class="line">    if (!ctx-&gt;isSocket() || ctx-&gt;getUserNonblock())</span><br><span class="line">    &#123;</span><br><span class="line">        return fun(fd, std::forward&lt;Args&gt;(args)...);</span><br><span class="line">    &#125;</span><br><span class="line">    //! 获取socket接收或发送的超时时间</span><br><span class="line">    uint64_t to = ctx-&gt;getTimeout(timeout_so);</span><br><span class="line">    std::shared_ptr&lt;timer_info&gt; tinfo(new timer_info);</span><br><span class="line"></span><br><span class="line">retry:</span><br><span class="line">    //! foward完美转发参数</span><br><span class="line">    ssize_t n = fun(fd, std::forward&lt;Args&gt;(args)...);</span><br><span class="line">    //! 读写时发生中断</span><br><span class="line">    while (n == -1 &amp;&amp; errno == EINTR)</span><br><span class="line">    &#123;</span><br><span class="line">        //! 重新调用</span><br><span class="line">        n = fun(fd, std::forward&lt;Args&gt;(args)...);</span><br><span class="line">    &#125;</span><br><span class="line">    //! 连续做read操作而没有数据可读</span><br><span class="line">    if (n == -1 &amp;&amp; errno == EAGAIN)</span><br><span class="line">    &#123;</span><br><span class="line">        HPS::IOManager *iom = HPS::IOManager::GetThis();</span><br><span class="line">        HPS::Timer::ptr timer;</span><br><span class="line">        std::weak_ptr&lt;timer_info&gt; winfo(tinfo);</span><br><span class="line"></span><br><span class="line">        if (to != (uint64_t)-1)</span><br><span class="line">        &#123;</span><br><span class="line">            timer = iom-&gt;addConditionTimer(</span><br><span class="line">                to, [winfo, fd, iom, event]()</span><br><span class="line">                &#123;</span><br><span class="line">                auto t = winfo.lock();</span><br><span class="line">                if(!t || t-&gt;cancelled) &#123;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                t-&gt;cancelled = ETIMEDOUT;</span><br><span class="line">                //! 执行并取消事件</span><br><span class="line">                iom-&gt;cancelEvent(fd, (HPS::IOManager::Event)(event)); &#125;,</span><br><span class="line">                winfo);</span><br><span class="line">        &#125;</span><br><span class="line">        //! 添加事件的回调为空,默认当前协程为回调</span><br><span class="line">        int rt = iom-&gt;addEvent(fd, (HPS::IOManager::Event)(event));</span><br><span class="line">        //! 添加事件失败</span><br><span class="line">        if (UNLIKELY(rt))</span><br><span class="line">        &#123;</span><br><span class="line">            LOG_ERROR(g_logger) &lt;&lt; hook_fun_name &lt;&lt; &quot; addEvent(&quot;</span><br><span class="line">                                &lt;&lt; fd &lt;&lt; &quot;, &quot; &lt;&lt; event &lt;&lt; &quot;)&quot;;</span><br><span class="line">            if (timer)</span><br><span class="line">            &#123;</span><br><span class="line">                timer-&gt;cancel();</span><br><span class="line">            &#125;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            //! 添加事件成功</span><br><span class="line">            //! 让出协程执行权限???</span><br><span class="line">            HPS::Fiber::YieldToHold();</span><br><span class="line">            //! 当条件定时器超时时,会唤醒协程,当数据回来时,也会唤醒协程</span><br><span class="line">            if (timer)</span><br><span class="line">            &#123;</span><br><span class="line">                timer-&gt;cancel();</span><br><span class="line">            &#125;</span><br><span class="line">            //! 通过定时任务唤醒</span><br><span class="line">            if (tinfo-&gt;cancelled)</span><br><span class="line">            &#123;</span><br><span class="line">                errno = tinfo-&gt;cancelled;</span><br><span class="line">                return -1;</span><br><span class="line">            &#125;</span><br><span class="line">            //! 有IO事件,需要重新读</span><br><span class="line">            goto retry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用自定义钩子函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ssize_t read(int fd, void *buf, size_t count)</span><br><span class="line">&#123;</span><br><span class="line">    return do_io(fd, read_f, &quot;read&quot;, HPS::IOManager::READ, SO_RCVTIMEO, buf, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="网络地址模块"><a href="#网络地址模块" class="headerlink" title="网络地址模块"></a>网络地址模块</h1><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2></li>
</ol>
<ul>
<li>通过域名、端口、网卡来获取主机的网络地址等信息<h2 id="类图-1"><a href="#类图-1" class="headerlink" title="类图"></a>类图</h2></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">classDiagram</span><br><span class="line">    IPAddress --|&gt; Address : 继承</span><br><span class="line">    UnixAddress --|&gt; Address : 继承</span><br><span class="line">    IPv4Address --|&gt; IPAddress : 继承</span><br><span class="line">    IPv6Address --|&gt; IPAddress : 继承</span><br><span class="line">    </span><br><span class="line">    class Address&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    class IPAddress&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    class UnixAddress&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    class IPv4Address&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    class IPv6Address&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h2 id="组件-10"><a href="#组件-10" class="headerlink" title="组件"></a>组件</h2><ul>
<li>网络地址的基类(Address)<ul>
<li>成员函数<ul>
<li>通过sockaddr指针创建Address</li>
<li>通过host地址返回对应条件的所有Address</li>
<li>通过host地址返回对应条件的任意Address</li>
<li>通过host地址返回对应条件的任意IPAddress</li>
<li>返回本机所有网卡的&lt;网卡名, 地址, 子网掩码位数&gt;</li>
<li>获取指定网卡的地址和子网掩码位数</li>
<li>可读性输出地址</li>
<li>返回协议簇、sockaddr指针,只读、长度、可读性字符串</li>
</ul>
</li>
</ul>
</li>
<li>IP地址的基类(IPAddress)(继承网络地址的基类)<ul>
<li>通过域名,IP,服务器名创建IPAddress</li>
<li>获取该地址的广播地址</li>
<li>获取该地址的网段</li>
<li>获取子网掩码地址</li>
<li>返回、设置端口号</li>
</ul>
</li>
<li>IPv4地址(IPv4Addres)(继承IP地址的基类)<ul>
<li>使用点分十进制地址创建IPv4Address</li>
<li>通过sockaddr_in构造IPv4Address</li>
<li>通过二进制地址构造IPv4Address</li>
</ul>
</li>
<li>IPv6地址(IPv6Address)(继承IP地址的基类)<ul>
<li>通过IPv6地址字符串构造IPv6Address</li>
<li>通过sockaddr_in6构造IPv6Address</li>
<li>通过IPv6二进制地址构造IPv6Address</li>
</ul>
</li>
<li>UnixSocket地址(UnixAddress)(继承网络地址的基类)<ul>
<li>通过路径构造UnixAddress</li>
</ul>
</li>
<li>未知地址(UnknownAddress)(继承网络地址的基类)</li>
</ul>
<h2 id="整体逻辑-10"><a href="#整体逻辑-10" class="headerlink" title="整体逻辑"></a>整体逻辑</h2><ol>
<li>通过域名及端口地址返回对应条件的所有addrinfo结构体<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">bool Address::Lookup(std::vector&lt;Address::ptr&gt; &amp;result, const std::string &amp;host,</span><br><span class="line">                         int family, int type, int protocol)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        addrinfo hints, *results, *next;</span><br><span class="line">        //! 初始化网络地址结构体addrinfo</span><br><span class="line">        hints.ai_flags = 0;</span><br><span class="line">        hints.ai_family = family;</span><br><span class="line">        hints.ai_socktype = type;</span><br><span class="line">        hints.ai_protocol = protocol;</span><br><span class="line">        hints.ai_addrlen = 0;</span><br><span class="line">        //! 主机的规范名称</span><br><span class="line">        hints.ai_canonname = NULL;</span><br><span class="line">        hints.ai_addr = NULL;</span><br><span class="line">        //! 地址列表中的下一个地址</span><br><span class="line">        hints.ai_next = NULL;</span><br><span class="line"></span><br><span class="line">        std::string node;</span><br><span class="line">        const char *service = NULL;</span><br><span class="line"></span><br><span class="line">        //! 若为 ipv6address serivce如：[1002:003B:456C:678D:890E:0012:234F:56G7]:3306</span><br><span class="line">        if (!host.empty() &amp;&amp; host[0] == &#x27;[&#x27;)</span><br><span class="line">        &#123;</span><br><span class="line">            const char *endipv6 = (const char *)memchr(host.c_str() + 1, &#x27;]&#x27;, host.size() - 1);</span><br><span class="line">            if (endipv6)</span><br><span class="line">            &#123;</span><br><span class="line">                // TODO check out of range</span><br><span class="line">                //! service为端口</span><br><span class="line">                if (*(endipv6 + 1) == &#x27;:&#x27;)</span><br><span class="line">                &#123;</span><br><span class="line">                    service = endipv6 + 2;</span><br><span class="line">                &#125;</span><br><span class="line">                node = host.substr(1, endipv6 - host.c_str() - 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //! 若为IPv4,不为检查 node serivce</span><br><span class="line">        if (node.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            service = (const char *)memchr(host.c_str(), &#x27;:&#x27;, host.size());</span><br><span class="line">            if (service)</span><br><span class="line">            &#123;</span><br><span class="line">                if (!memchr(service + 1, &#x27;:&#x27;, host.c_str() + host.size() - service - 1))</span><br><span class="line">                &#123;</span><br><span class="line">                    node = host.substr(0, service - host.c_str());</span><br><span class="line">                    ++service;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //! 没有端口</span><br><span class="line">        if (node.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            node = host;</span><br><span class="line">        &#125;</span><br><span class="line">        //! 参数分别是：域名，端口，用户设定的 struct addrinfo 结构体，通过result指针参数返回一个指向addrinfo结构体链表的指针</span><br><span class="line">        int error = getaddrinfo(node.c_str(), service, &amp;hints, &amp;results);</span><br><span class="line">        if (error)</span><br><span class="line">        &#123;</span><br><span class="line">            LOG_DEBUG(g_logger) &lt;&lt; &quot;Address::Lookup getaddress(&quot; &lt;&lt; host &lt;&lt; &quot;, &quot;</span><br><span class="line">                                &lt;&lt; family &lt;&lt; &quot;, &quot; &lt;&lt; type &lt;&lt; &quot;) err=&quot; &lt;&lt; error &lt;&lt; &quot; errstr=&quot;</span><br><span class="line">                                &lt;&lt; gai_strerror(error);</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        next = results;</span><br><span class="line">        //! 递归查询所有有关IP地址结构</span><br><span class="line">        while (next)</span><br><span class="line">        &#123;</span><br><span class="line">            result.push_back(Create(next-&gt;ai_addr, (socklen_t)next-&gt;ai_addrlen));</span><br><span class="line">            // LOG_INFO(g_logger) &lt;&lt; ((sockaddr_in*)next-&gt;ai_addr)-&gt;sin_addr.s_addr;</span><br><span class="line">            next = next-&gt;ai_next;</span><br><span class="line">        &#125;</span><br><span class="line">        //! 释放内存</span><br><span class="line">        freeaddrinfo(results);</span><br><span class="line">        return !result.empty();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>2.1) 返回本机所有网卡的&lt;网卡名, 地址, 子网掩码位数&gt;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">bool Address::GetInterfaceAddresses(std::multimap&lt;std::string, std::pair&lt;Address::ptr, uint32_t&gt;&gt; &amp;result,</span><br><span class="line">                                        int family)</span><br><span class="line">    &#123;</span><br><span class="line">        //! 获取本地网络接口的信息。</span><br><span class="line">        //! 在路由器上可以用这个接口来获取wan/lan等接口当前的ip地址，广播地址等信息。</span><br><span class="line">        struct ifaddrs *next, *results;</span><br><span class="line">        if (getifaddrs(&amp;results) != 0)</span><br><span class="line">        &#123;</span><br><span class="line">            LOG_DEBUG(g_logger) &lt;&lt; &quot;Address::GetInterfaceAddresses getifaddrs &quot;</span><br><span class="line">                                   &quot; err=&quot;</span><br><span class="line">                                &lt;&lt; errno &lt;&lt; &quot; errstr=&quot; &lt;&lt; strerror(errno);</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            for (next = results; next; next = next-&gt;ifa_next)</span><br><span class="line">            &#123;</span><br><span class="line">                Address::ptr addr;</span><br><span class="line">                uint32_t prefix_len = ~0u;</span><br><span class="line">                //! AF_UNSPEC则意味着函数返回的是适用于指定主机名和服务名且适合任何协议族的地址。</span><br><span class="line">                if (family != AF_UNSPEC &amp;&amp; family != next-&gt;ifa_addr-&gt;sa_family)</span><br><span class="line">                &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                switch (next-&gt;ifa_addr-&gt;sa_family)</span><br><span class="line">                &#123;</span><br><span class="line">                case AF_INET:</span><br><span class="line">                &#123;</span><br><span class="line">                    //! 创建网络地址基类指针指向不同类型的地址子类</span><br><span class="line">                    addr = Create(next-&gt;ifa_addr, sizeof(sockaddr_in));</span><br><span class="line">                    uint32_t netmask = ((sockaddr_in *)next-&gt;ifa_netmask)-&gt;sin_addr.s_addr;</span><br><span class="line">                    //! 返回子网掩码位数</span><br><span class="line">                    prefix_len = CountBytes(netmask);</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">                case AF_INET6:</span><br><span class="line">                &#123;</span><br><span class="line">                    addr = Create(next-&gt;ifa_addr, sizeof(sockaddr_in6));</span><br><span class="line">                    in6_addr &amp;netmask = ((sockaddr_in6 *)next-&gt;ifa_netmask)-&gt;sin6_addr;</span><br><span class="line">                    prefix_len = 0;</span><br><span class="line">                    for (int i = 0; i &lt; 16; ++i)</span><br><span class="line">                    &#123;</span><br><span class="line">                        prefix_len += CountBytes(netmask.s6_addr[i]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">                default:</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (addr)</span><br><span class="line">                &#123;</span><br><span class="line">                    result.insert(std::make_pair(next-&gt;ifa_name,</span><br><span class="line">                                                 std::make_pair(addr, prefix_len)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        catch (...)</span><br><span class="line">        &#123;</span><br><span class="line">            LOG_ERROR(g_logger) &lt;&lt; &quot;Address::GetInterfaceAddresses exception&quot;;</span><br><span class="line">            freeifaddrs(results);</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        freeifaddrs(results);</span><br><span class="line">        return !result.empty();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>2.2) 通过网卡名称获取指定网卡的地址和子网掩码位数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">bool Address::GetInterfaceAddresses(std::vector&lt;std::pair&lt;Address::ptr, uint32_t&gt;&gt; &amp;result, const std::string &amp;iface, int family)</span><br><span class="line">    &#123;</span><br><span class="line">        if (iface.empty() || iface == &quot;*&quot;)</span><br><span class="line">        &#123;</span><br><span class="line">            if (family == AF_INET || family == AF_UNSPEC)</span><br><span class="line">            &#123;</span><br><span class="line">                result.push_back(std::make_pair(Address::ptr(new IPv4Address()), 0u));</span><br><span class="line">            &#125;</span><br><span class="line">            if (family == AF_INET6 || family == AF_UNSPEC)</span><br><span class="line">            &#123;</span><br><span class="line">                result.push_back(std::make_pair(Address::ptr(new IPv6Address()), 0u));</span><br><span class="line">            &#125;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::multimap&lt;std::string, std::pair&lt;Address::ptr, uint32_t&gt;&gt; results;</span><br><span class="line"></span><br><span class="line">        if (!GetInterfaceAddresses(results, family))</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        auto its = results.equal_range(iface);</span><br><span class="line">        for (; its.first != its.second; ++its.first)</span><br><span class="line">        &#123;</span><br><span class="line">            result.push_back(its.first-&gt;second);</span><br><span class="line">        &#125;</span><br><span class="line">        return !result.empty();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="测试-4"><a href="#测试-4" class="headerlink" title="测试"></a>测试</h2><h1 id="socket封装模块"><a href="#socket封装模块" class="headerlink" title="socket封装模块"></a>socket封装模块</h1><h2 id="概述-11"><a href="#概述-11" class="headerlink" title="概述"></a>概述</h2><ul>
<li>功能<ul>
<li>封装socket对用户提供简单易用的API</li>
</ul>
</li>
</ul>
<h2 id="组件-11"><a href="#组件-11" class="headerlink" title="组件"></a>组件</h2><ul>
<li>Socket封装类(Socket)<ul>
<li>成员属性(保护)<ul>
<li>socket句柄</li>
<li>协议簇</li>
<li>类型<ul>
<li>TCP类型：SOCK_STREAM</li>
<li>UDP类型：SOCK_DGRAM</li>
</ul>
</li>
<li>协议</li>
<li>是否连接</li>
<li>本地地址</li>
<li>远端地址</li>
</ul>
</li>
<li>成员函数(公有)<ul>
<li>创建TCP Socket(满足地址类型)</li>
<li>创建UDP Socket(满足地址类型)</li>
<li>创建IPv4&#x2F;IPv6&#x2F;Unix的TCP&#x2F;UDPSocket</li>
<li>构造、析构函数</li>
<li>获取&#x2F;设置 发送&#x2F;接受超时时间(毫秒)</li>
<li>获取&#x2F;设置 sockopt&#x2F;sockopt模板</li>
<li>接收connect链接</li>
<li>绑定(bind)、（重新）连接(connect)、监听(listen)、关闭(socket)、发送(send)、接受(recv)</li>
<li>获取成员属性远端地址、本地地址、协议簇、类型</li>
<li>返回是否连接、是否有效、socket错误、socket句柄</li>
<li>取消读&#x2F;写、accept、所有事件</li>
<li>输出信息到流中</li>
</ul>
</li>
<li>成员函数(保护)<ul>
<li>初始化、创建socket</li>
<li>初始化sock</li>
</ul>
</li>
</ul>
</li>
<li>SSLSocket封装(继承自Socket)<h2 id="整体逻辑-11"><a href="#整体逻辑-11" class="headerlink" title="整体逻辑"></a>整体逻辑</h2><h2 id="测试-5"><a href="#测试-5" class="headerlink" title="测试"></a>测试</h2></li>
</ul>
<h1 id="序列化与反序列化模块"><a href="#序列化与反序列化模块" class="headerlink" title="序列化与反序列化模块!!!"></a>序列化与反序列化模块!!!</h1><h2 id="概述-12"><a href="#概述-12" class="headerlink" title="概述"></a>概述</h2><ul>
<li>功能<ul>
<li>序列化的原本意图是希望对一个对象作一下“变换”，变成字节序列，这样一来<strong>方便持久化存储到磁盘</strong>，避免程序运行结束后对象就从内存里消失，另外变换成字节序列也更便于网络运输和传播</li>
</ul>
</li>
</ul>
<h1 id="网络模块"><a href="#网络模块" class="headerlink" title="网络模块"></a>网络模块</h1><h2 id="概述-13"><a href="#概述-13" class="headerlink" title="概述"></a>概述</h2><ul>
<li>功能</li>
</ul>
<h2 id="组件-12"><a href="#组件-12" class="headerlink" title="组件"></a>组件</h2><h3 id="HTTP请求-x2F-响应报文封装"><a href="#HTTP请求-x2F-响应报文封装" class="headerlink" title="HTTP请求&#x2F;响应报文封装"></a>HTTP请求&#x2F;响应报文封装</h3><ul>
<li>http请求枚举（HTTP_METHOD_MAP(num, name, string)）<ul>
<li>编号</li>
<li>名称</li>
</ul>
</li>
<li>http状态枚举（HTTP_STATUS_MAP(code, name, desc)）<ul>
<li>状态码</li>
<li>状态名称</li>
<li>描述</li>
</ul>
</li>
<li>通用方法<ul>
<li>字符串方法名、字符串指针和HTTP方法枚举的相互转换</li>
<li>获取Map中的key值,并转成对应类型,返回是否成功</li>
</ul>
</li>
<li>HTTP请求结构（HttpRequest）<ul>
<li>成员属性（私有）<ul>
<li>HTTP方法</li>
<li>HTTP版本</li>
<li>是否自动关闭</li>
<li>是否为websocket</li>
<li>请求路径</li>
<li>请求参数</li>
<li>请求fragment</li>
<li>请求消息体</li>
<li>请求头部MAP</li>
<li>请求参数MAP</li>
<li>请求Cookie MAP</li>
</ul>
</li>
<li>成员函数（公有）<ul>
<li>构造函数，设置版本、是否keepalive</li>
<li>返回、设置成员属性</li>
<li>设置HTTP请求的方法名、HTTP请求的协议版本、HTTP请求的路径、HTTP请求的查询参数、HTTP请求的Fragment、HTTP请求的消息体</li>
<li>返回、设置是否自动关闭、是否websocket</li>
<li>设置HTTP请求的头部MAP、HTTP请求的参数MAP、HTTP请求的Cookie MAP</li>
<li>获取、设置、删除HTTP请求的头部参数、HTTP请求的请求参数、HTTP请求的Cookie参数</li>
<li>判断HTTP请求的头部参数、请求参数、Cookie参数是否存在</li>
<li>检查并获取HTTP请求的头部参数、获取HTTP请求的头部参数、检查并获取HTTP请求的请求参数、获取HTTP请求的请求参数、检查并获取HTTP请求的Cookie参数、获取HTTP请求的Cookie参数</li>
<li>序列化输出到流中</li>
<li>转成字符串类型</li>
</ul>
</li>
</ul>
</li>
<li>HTTP响应结构体（HttpResponse）<ul>
<li>成员属性（私有）<ul>
<li>响应状态</li>
<li>版本</li>
<li>是否自动关闭</li>
<li>是否为websocket</li>
<li>响应消息体</li>
<li>响应原因</li>
<li>响应头部MAP</li>
</ul>
</li>
<li>成员函数（公有）<ul>
<li>构造函数（版本、是否自动关闭）</li>
<li>返回、设置成员属性、是否自动关闭、是否websocket</li>
<li>获取、设置、删除、检查并获取响应头部参数</li>
<li>序列化输出到流</li>
<li>转成字符串</li>
</ul>
</li>
</ul>
</li>
<li>HTTPSession封装（HttpSession）<ul>
<li>成员函数（公有）<ul>
<li>构造函数</li>
<li>接收HTTP请求</li>
<li>发送HTTP响应</li>
</ul>
</li>
</ul>
</li>
<li>HTTP请求解析类（HttpRequest）</li>
</ul>
<h3 id="HTTP解析封装"><a href="#HTTP解析封装" class="headerlink" title="HTTP解析封装"></a>HTTP解析封装</h3><ul>
<li>功能<ul>
<li>对HTTP的请求行&#x2F;头进行解析</li>
</ul>
</li>
<li>HTTP请求解析类<ul>
<li>成员属性（私有）<ul>
<li>http_parser</li>
<li>HttpRequest结构</li>
<li>错误码</li>
</ul>
</li>
<li>成员函数（公有）<ul>
<li>构造函数</li>
<li>解析协议</li>
<li>是否解析完成、有错误</li>
<li>返回HttpRequest结构体</li>
<li>设置错误</li>
<li>获取消息体长度</li>
<li>获取http_parser结构体</li>
<li>返回HttpRequest协议解析的缓存大小</li>
<li>返回HttpRequest协议的最大消息体大小</li>
</ul>
</li>
</ul>
</li>
<li>Http响应解析结构体<ul>
<li><p>成员属性（私有）</p>
<ul>
<li>httpclient_parser</li>
<li>HttpResponse结构</li>
<li>错误码</li>
</ul>
</li>
<li><p>成员函数（公有）</p>
<ul>
<li>构造函数</li>
<li>解析HTTP响应协议</li>
<li>是否解析完成、有错误</li>
<li>返回HttpResponse</li>
<li>设置错误码</li>
<li>获取消息体长度</li>
<li>返回httpclient_parser</li>
<li>返回HTTP响应解析缓存大小</li>
<li>返回HTTP响应最大消息体大小</li>
</ul>
</li>
</ul>
</li>
<li>HTTP解析库http-parser、httpclient_parser<ul>
<li>http-parser是一个用C编写的HTTP消息解析器，可以解析请求和响应</li>
<li>设计用于高性能HTTP应用程序</li>
<li>它不会进行任何系统调用及内存分配，它不会缓冲数据，它可以被随时中断。根据你的体系结构，每个消息流只需要大约40个字节的数据(在每个连接的web服务器中。它的源码在<a target="_blank" rel="noopener" href="https://github.com/nodejs/http-parser">https://github.com/nodejs/http-parser</a> ，License为MIT，最新发布版为v2.8.1.</li>
<li>不依赖第三方库；处理持续流(keep-alive)；分块解码(decodes chunked encoding)；支持Upgrade；防止缓冲区溢出攻击。</li>
<li>可以从HTTP消息中解析下列信息：报头域及值(Header fields and values)；内容长度(Content-Length)；请求方法；响应状态码；传输编码；HTTP版本；请求URL(网址)；消息体(Message body)。</li>
<li>每个TCP连接使用一个http_parser对象。使用http_parser_init函数初始化结构体并设置回调。</li>
</ul>
</li>
</ul>
<h3 id="流结构"><a href="#流结构" class="headerlink" title="流结构"></a>流结构</h3><ul>
<li>流类（stream）<ul>
<li>成员属性（私有）</li>
<li>成员函数（公有）<ul>
<li>读数据</li>
<li>读固定长度的数据</li>
<li>写数据</li>
<li>写固定长度的数据</li>
<li>关闭流</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Socket流"><a href="#Socket流" class="headerlink" title="Socket流"></a>Socket流</h3><ul>
<li>Socket流类（SocketStream）继承stream<ul>
<li>成员属性（私有）<ul>
<li>Socket类（Socket::ptr）</li>
<li>是否主控</li>
</ul>
</li>
<li>成员函数（公有）<ul>
<li>构造、析构函数</li>
<li>读取数据</li>
<li>写入数据</li>
<li>关闭socket</li>
<li>返回Socket类、是否连接</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="HTTP-Session封装"><a href="#HTTP-Session封装" class="headerlink" title="HTTP Session封装"></a>HTTP Session封装</h3><ul>
<li>HTTPSession封装类（HttpSession）继承SocketStream<ul>
<li>成员属性（私有）</li>
<li>成员函数（公有）<ul>
<li>构造函数</li>
<li>接收HTTP请求</li>
<li>发送HTTP响应</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="TCP服务器"><a href="#TCP服务器" class="headerlink" title="TCP服务器"></a>TCP服务器</h3><ul>
<li>TCP服务器封装(TcpServer)<ul>
<li>成员函数<ul>
<li>构造、析构函数</li>
<li>绑定地址</li>
<li>开始接受连接</li>
<li>启动服务</li>
<li>停止服务</li>
<li>返回读取超时时间(毫秒)</li>
<li>返回服务器名称</li>
<li>设置读取超时时间(毫秒)</li>
<li>是否停止</li>
</ul>
</li>
<li>成员属性（私有）<ul>
<li>监听Socket数组</li>
<li>新连接的Socket工作的调度器</li>
<li>服务器Socket接收连接的调度器</li>
<li>接收超时时间(毫秒)</li>
<li>服务器名称、类型、服务是否停止</li>
<li>服务器配置</li>
</ul>
</li>
</ul>
</li>
<li>整体逻辑<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">void run() &#123;</span><br><span class="line">    //! 返回本机任意网络地址，形成套接字</span><br><span class="line">    auto addr = HPS::Address::LookupAny(&quot;0.0.0.0:8033&quot;);</span><br><span class="line">    //auto addr2 = HPS::UnixAddress::ptr(new HPS::UnixAddress(&quot;/tmp/unix_addr&quot;));</span><br><span class="line">    std::vector&lt;HPS::Address::ptr&gt; addrs;</span><br><span class="line">    addrs.push_back(addr);</span><br><span class="line">    //addrs.push_back(addr2);</span><br><span class="line">    //! 创建TCP服务器</span><br><span class="line">    HPS::TcpServer::ptr tcp_server(new HPS::TcpServer);</span><br><span class="line">    std::vector&lt;HPS::Address::ptr&gt; fails;</span><br><span class="line">    //! 与本机网络地址绑定</span><br><span class="line">    while(!tcp_server-&gt;bind(addrs, fails)) &#123;</span><br><span class="line">        sleep(2);</span><br><span class="line">    &#125;</span><br><span class="line">    //! 启动服务器</span><br><span class="line">    tcp_server-&gt;start();</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char** argv) &#123;</span><br><span class="line">    //! 启动IO调度器</span><br><span class="line">    HPS::IOManager iom(2);</span><br><span class="line">    iom.schedule(run);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h3><ul>
<li><p>简介</p>
<ul>
<li>HttpServlet是Servlet接口的一个实现类，并且它是一个抽象类，servlet.http包中定义了采用HTTP通信协议(一个无状态协议)的HttpServlet类。</li>
</ul>
</li>
<li><p>响应流程</p>
<ul>
<li>Web客户向Servlet容器发出Http请求</li>
<li>Servlet容器解析Web客户的Http请求</li>
<li>Servlet容器创建一个HttpRequest对象，在这个对象中封装Http请求信息</li>
<li>Servlet容器创建一个HttpResponse对象</li>
<li>Servlet容器调用HttpServlet的service方法，把HttpRequest和HttpResponse对象作为service方法的参数传给HttpServlet对象</li>
<li>HttpServlet调用HttpRequest的有关方法，获取HTTP请求信息</li>
<li>HttpServlet调用HttpResponse的有关方法，生成响应数据</li>
<li>Servlet容器把HttpServlet的响应结果传给Web客户</li>
<li>其中HttpServlet首先必须读取Http请求的内容，Servlet容器负责创建HttpServlet对象，并把Http请求直接封装到HttpServlet对象中。</li>
</ul>
</li>
<li><p>创建HttpServlet步骤</p>
<ul>
<li>继承HttpServlet抽象类</li>
<li>重写HttpServlet的部分方法，如doGet()或doPost()方法</li>
<li>获取HTTP请求信息。通过HttpServletRequest对象来检索HTML表单所提交的数据或URL上的查询字符串</li>
<li>生成HTTP响应结果。通过HttpServletResponse对象生成响应结果</li>
</ul>
</li>
<li><p>具体实现</p>
<ul>
<li>HttpServlet的实现由两种方式：<ul>
<li>实现方式一：.xml配置实现<ul>
<li>配置xml文件(实现方式同Servlet接口的.xml配置相同,此处不再重复)</li>
<li>继承HttpServlet抽象类</li>
<li>重写get()、post()方法</li>
</ul>
</li>
<li>实现方式二：注解实现</li>
</ul>
</li>
</ul>
</li>
<li><p>重写doGet()和doPost()</p>
<ul>
<li>设置请求字符集</li>
<li>设置响应对象文本类型</li>
<li>通过请求对象获取用户输入的数据</li>
<li>响应对象通过重定向&#x2F;转发响应用户请求</li>
</ul>
</li>
<li><p>组件</p>
<ul>
<li><p>Servlet封装类（Servlet）（抽象基类）</p>
<ul>
<li>成员函数<ul>
<li>构造&#x2F;析构函数</li>
<li>处理请求</li>
<li>返回Servlet名称</li>
</ul>
</li>
<li>成员属性<ul>
<li>名称</li>
</ul>
</li>
</ul>
</li>
<li><p>函数式Servlet（FunctionServlet）</p>
<ul>
<li>成员函数<ul>
<li>构造函数</li>
</ul>
</li>
<li>成员属性<ul>
<li>回调函数</li>
</ul>
</li>
</ul>
</li>
<li><p>Servlet分发器（ServletDispatch）</p>
<ul>
<li>成员属性（私有）<ul>
<li>读写互斥量</li>
<li>精准匹配servlet MAP</li>
<li>模糊匹配servlet 数组</li>
<li>默认servlet，所有路径都没匹配到时使用</li>
</ul>
</li>
<li>成员函数（公有）<ul>
<li>构造函数</li>
<li>添加&#x2F;删除，servlet&#x2F;模糊匹配servlet</li>
<li>返回、设置默认servlet</li>
<li>通过uri获取servlet、模糊匹配servlet</li>
</ul>
</li>
<li>整体逻辑</li>
</ul>
<ol>
<li>创建分发器  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ServletDispatch::ServletDispatch()</span><br><span class="line">    : Servlet(&quot;ServletDispatch&quot;)</span><br><span class="line">&#123;</span><br><span class="line">    m_default.reset(new NotFoundServlet(&quot;HPS/1.0&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>处理请求，生成响应（递归）  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int32_t ServletDispatch::handle(HPS::http::HttpRequest::ptr request, HPS::http::HttpResponse::ptr response, HPS::http::HttpSession::ptr session)</span><br><span class="line">&#123;</span><br><span class="line">    auto slt = getMatchedServlet(request-&gt;getPath());</span><br><span class="line">    if (slt)</span><br><span class="line">    &#123;</span><br><span class="line">        slt-&gt;handle(request, response, session);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>向服务器添加Servlet  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//! 设定0.0.0.0:8020/HPS/xx此路径的消息体</span><br><span class="line">sd-&gt;addServlet(&quot;/HPS/xx&quot;, [](HPS::http::HttpRequest::ptr req, HPS::http::HttpResponse::ptr rsp, HPS::http::HttpSession::ptr session)</span><br><span class="line">               &#123;</span><br><span class="line">            rsp-&gt;setBody(req-&gt;toString());</span><br><span class="line">            return 0; &#125;);</span><br><span class="line">            </span><br><span class="line">void ServletDispatch::addServlet(const std::string &amp;uri, FunctionServlet::callback cb)</span><br><span class="line">&#123;</span><br><span class="line">    RWMutexType::WriteLock lock(m_mutex);</span><br><span class="line">    //! 这里构造FunctionServlet对象自动触发回调函数cb</span><br><span class="line">    m_datas[uri] = std::make_shared&lt;HoldServletCreator&gt;(</span><br><span class="line">        std::make_shared&lt;FunctionServlet&gt;(cb));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FunctionServlet::FunctionServlet(callback cb)</span><br><span class="line">: Servlet(&quot;FunctionServlet&quot;), m_cb(cb)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="HTTP服务器"><a href="#HTTP服务器" class="headerlink" title="HTTP服务器"></a>HTTP服务器</h3><ul>
<li>HTTP服务器类(HttpServer)<ul>
<li>成员函数（公有）<ul>
<li>构造函数</li>
<li>获取ServletDispatch</li>
</ul>
</li>
<li><h2 id="成员函数（保护）"><a href="#成员函数（保护）" class="headerlink" title="成员函数（保护）"></a>成员函数（保护）</h2></li>
<li>成员属性（私有）<ul>
<li>是否支持长连接</li>
<li>Servlet分发器</li>
</ul>
</li>
<li>测试</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">HPS::IOManager::ptr worker;</span><br><span class="line">void run()</span><br><span class="line">&#123;</span><br><span class="line">    // g_logger-&gt;setLevel(HPS::LogLevel::INFO);</span><br><span class="line">    // HPS::http::HttpServer::ptr server(new HPS::http::HttpServer(true, worker.get(), HPS::IOManager::GetThis()));</span><br><span class="line">    //! 创建HTTP服务器</span><br><span class="line">    HPS::http::HttpServer::ptr server(new HPS::http::HttpServer(true));</span><br><span class="line">    //! 返回本地主机套接字</span><br><span class="line">    HPS::Address::ptr addr = HPS::Address::LookupAnyIPAddress(&quot;0.0.0.0:8020&quot;);</span><br><span class="line">    //! 绑定</span><br><span class="line">    while (!server-&gt;bind(addr))</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(2);</span><br><span class="line">    &#125;</span><br><span class="line">    //! 取得服务器Servlet分发器</span><br><span class="line">    auto sd = server-&gt;getServletDispatch();</span><br><span class="line">    //! 设定0.0.0.0:8020/HPS/xx此路径的消息体</span><br><span class="line">    sd-&gt;addServlet(&quot;/HPS/xx&quot;, [](HPS::http::HttpRequest::ptr req, HPS::http::HttpResponse::ptr rsp, HPS::http::HttpSession::ptr session)</span><br><span class="line">                   &#123;</span><br><span class="line">                rsp-&gt;setBody(req-&gt;toString());</span><br><span class="line">                return 0; &#125;);</span><br><span class="line">    //! 设定0.0.0.0:8020/HPS/此路径的消息体</span><br><span class="line">    sd-&gt;addGlobServlet(&quot;/HPS/*&quot;, [](HPS::http::HttpRequest::ptr req, HPS::http::HttpResponse::ptr rsp, HPS::http::HttpSession::ptr session)</span><br><span class="line">                       &#123;</span><br><span class="line">                rsp-&gt;setBody(&quot;Glob:\r\n&quot; + req-&gt;toString());</span><br><span class="line">                return 0; &#125;);</span><br><span class="line"></span><br><span class="line">    //     sd-&gt;addGlobServlet(&quot;/sylarx/*&quot;, [](HPS::http::HttpRequest::ptr req, HPS::http::HttpResponse::ptr rsp, HPS::http::HttpSession::ptr session)</span><br><span class="line">    //                        &#123;</span><br><span class="line">    //             rsp-&gt;setBody(XX(&lt;html&gt;</span><br><span class="line">    // &lt;head&gt;&lt;title&gt;404 Not Found&lt;/title&gt;&lt;/head&gt;</span><br><span class="line">    // &lt;body&gt;</span><br><span class="line">    // &lt;center&gt;&lt;h1&gt;404 Not Found&lt;/h1&gt;&lt;/center&gt;</span><br><span class="line">    // &lt;hr&gt;&lt;center&gt;nginx/1.16.0&lt;/center&gt;</span><br><span class="line">    // &lt;/body&gt;</span><br><span class="line">    // &lt;/html&gt;</span><br><span class="line">    // &lt;!-- a padding to disable MSIE and Chrome friendly error page --&gt;</span><br><span class="line">    // &lt;!-- a padding to disable MSIE and Chrome friendly error page --&gt;</span><br><span class="line">    // &lt;!-- a padding to disable MSIE and Chrome friendly error page --&gt;</span><br><span class="line">    // &lt;!-- a padding to disable MSIE and Chrome friendly error page --&gt;</span><br><span class="line">    // &lt;!-- a padding to disable MSIE and Chrome friendly error page --&gt;</span><br><span class="line">    // &lt;!-- a padding to disable MSIE and Chrome friendly error page --&gt;</span><br><span class="line">    // ));</span><br><span class="line">    //             return 0; &#125;);</span><br><span class="line">    //! 启动HTTP服务器</span><br><span class="line">    server-&gt;start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">    HPS::IOManager iom(1);</span><br><span class="line">    // worker.reset(new HPS::IOManager(3, false, &quot;worker&quot;));</span><br><span class="line">    iom.schedule(run);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​        </p>
<h1 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h1><ul>
<li>(!!!)代表可仔细考究， (???)代表不解的问题</li>
<li>词条结构<h2 id="概述-14"><a href="#概述-14" class="headerlink" title="概述"></a>概述</h2><ul>
<li>功能<h2 id="组件-13"><a href="#组件-13" class="headerlink" title="组件"></a>组件</h2></li>
<li>某某类<ul>
<li>成员属性（私有）</li>
<li>成员函数（公有）<h2 id="整体逻辑-12"><a href="#整体逻辑-12" class="headerlink" title="整体逻辑"></a>整体逻辑</h2><h2 id="测试-6"><a href="#测试-6" class="headerlink" title="测试"></a>测试</h2></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="报错与调试"><a href="#报错与调试" class="headerlink" title="报错与调试"></a>报错与调试</h1><ul>
<li>在test_scheduler时发生报错<ul>
<li>原因：注释掉了Fiber::中的makecontext</li>
</ul>
</li>
</ul>
<h1 id="需要研究的开发机制"><a href="#需要研究的开发机制" class="headerlink" title="需要研究的开发机制"></a>需要研究的开发机制</h1><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><ul>
<li>为什么需要协程？<ul>
<li>每个线程至少会占用4M的内存空间，10000个线程会消耗39G的内存，而服务器的内存配置只有区区8G<ul>
<li>2种选择，一是选择增加服务器，二是选择提高代码效率</li>
</ul>
</li>
<li>操作系统在线程等待IO的时候，会阻塞当前线程，切换到其它线程，当系统线程较少的时候没有什么问题，但是当线程数量非常多的时候，却产生了问题<ul>
<li>系统线程会占用非常多的内存空间</li>
<li>过多的线程切换会占用大量的系统时间。</li>
</ul>
</li>
<li>协程刚好可以解决上述2个问题<ul>
<li>协程运行在线程之上，当一个协程执行完成后，可以选择主动让出，让另一个协程运行在当前线程之上。</li>
<li><strong>协程并没有增加线程数量，只是在线程的基础之上通过分时复用的方式运行多个协程</strong></li>
<li>协程的切换在用户态完成，切换的代价比线程从用户态到内核态的代价小很多。</li>
</ul>
</li>
<li>我们只需要启动100个线程，每个线程上运行100个协程，这样不仅减少了线程切换开销，而且还能够同时处理10000个读取数据库的任务，很好的解决了上述任务。</li>
</ul>
</li>
<li>协程的注意事项<ul>
<li>协程只有在等待IO的过程中才能重复利用线程</li>
<li>假设协程运行在线程之上，并且协程调用了一个阻塞IO操作，这时候会发生什么？<ul>
<li>操作系统并不知道协程的存在，它只知道线程</li>
<li>因此在协程调用阻塞IO操作的时候，操作系统会让线程进入阻塞状态，当前的协程和其它绑定在该线程之上的协程都会陷入阻塞而得不到调度，这往往是不能接受的。</li>
<li>因此在协程中不能调用导致线程阻塞的操作。也就是说，协程只有和异步IO结合起来，才能发挥最大的威力。那么如何处理在协程中调用阻塞IO的操作呢？一般有2种处理方式：</li>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><ul>
<li><p>概述：</p>
<ul>
<li>进程阻塞切换的CPU开销</li>
<li>在高并发的网络IO下，性能的最大绊脚石就是socket在阻塞后导致的进程上下文切换</li>
<li>大约一次进程上下文切换的开销是 3-5 微秒左右。</li>
<li>epoll 作为多路复用技术中的代表，和传统的阻塞网络IO相比，最大的性能提升就是<strong>节约掉了大量的进程上下文切换</strong></li>
<li>epoll 内部又涉及出了一套复杂的数据结构，包括一棵红黑树和一个就绪链表<br>  <img src="https://pica.zhimg.com/80/v2-be49bb55a09595a9ca8653ba5f8f3b14_720w.jpg?source=1940ef5c" alt="image"></li>
<li>这样应用层和内核态协作的时候就非常的容易了，最少只需要一个进程就可以维护成千上万甚至是百万级别的连接。</li>
<li>这个进程的简单地去就绪队列中查看有没有 Ready，需要被处理的 socket。有就拿走处理。只要活儿足够的多，epoll_wait根本都不会让进程阻塞。用户进程会一直干活，一直干活，直到epoll_wait里实在没活儿可干的时候才主动让出 CPU。大量地减少了进程切换次数</li>
<li>工作原理汇总图<br>  <img src="https://pic2.zhimg.com/80/v2-adf545de491e45398a0e4b5fb1ec4a98_720w.jpg?source=1940ef5c" alt="image"></li>
<li>红黑树的作用是仅仅是在管理大量连接的情况下，添加和删除 socket 非常的高效。如果epoll管理的socket固定的话，在数据收发的事件管理过程中其实红黑树是没有起作用的。</li>
<li>内核在socket上收到数据包以后，可以直接找到epitem(epoll item)，并把它插入到就绪队列里，然后等用户进程把事件取走。这个过程中，红黑树的作用并不会得到体现。</li>
</ul>
</li>
<li><p>原理解析</p>
<ul>
<li>从网卡接收数据说起<ul>
<li>网卡接收数据的过程：<ul>
<li>在 1 阶段，网卡收到网线传来的数据。</li>
<li>经过 2 阶段的硬件电路的传输。</li>
<li>最终 3 阶段将数据写入到内存中的某个地址上。</li>
</ul>
</li>
<li>这个过程涉及到DMA传输、IO通路选择等硬件有关的知识，但我们只需知道：网卡会把接收到的数据写入内存。</li>
</ul>
</li>
<li>如何知道接收了数据?<ul>
<li>中断<ul>
<li>计算机执行程序时，会有优先级的需求。一般而言，由硬件产生的信号需要CPU立马做出回应，不然数据可能就丢失了，所以它的优先级很高。</li>
<li>CPU理应中断掉正在执行的程序，去做出响应;当 CPU 完成对硬件的响应后，再重新执行用户程序。</li>
<li>它和函数调用差不多，只不过函数调用是事先定好位置，而中断的位置由“信号”决定。</li>
</ul>
</li>
<li>当网卡把数据写入到内存后，网卡向CPU发出一个中断信号，操作系统便能得知有新数据到来，再通过网卡中断程序去处理数据。</li>
</ul>
</li>
<li>进程阻塞为什么不占用 CPU 资源?<ul>
<li>了解 Epoll 本质的第三步，要从操作系统进程调度的角度来看数据接收。阻塞是进程调度的关键一环，指的是进程在等待某事件(如接收到网络数据)发生之前的等待状态，Recv、Select和Epoll都是阻塞方法。</li>
<li>Recv 是个阻塞方法，当程序运行到Recv时，它会一直等待，直到接收到数据才往下执行。那么阻塞的原理是什么?</li>
</ul>
</li>
<li>工作队列<ul>
<li>操作系统为了支持多任务，实现了进程调度的功能，会把进程分为“运行”和“等待”等几种状态</li>
<li>运行状态是进程获得 CPU 使用权，正在执行代码的状态;等待状态是阻塞状态，比如上述程序运行到 Recv 时，程序会从运行状态变为等待状态，接收到数据后又变回运行状态。操作系统会分时执行各个运行状态的进程，由于速度很快，看上去就像是同时执行多个任务。</li>
</ul>
</li>
<li>等待队列<ul>
<li>当进程执行到创建 Socket 的语句时，操作系统会创建一个由文件系统管理的 Socket 对象</li>
<li>这个 Socket 对象包含了发送缓冲区、接收缓冲区与等待队列等成员。等待队列是个非常重要的结构，它指向所有需要等待该 Socket 事件的进程。</li>
<li>当程序执行到Recv时，操作系统会将进程A从工作队列移动到该Socket的等待队列中(如下图)。</li>
</ul>
</li>
<li>唤醒进程<ul>
<li>当Socket接收到数据后，操作系统将该Socket等待队列上的进程重新放回到工作队列，该进程变成运行状态，继续执行代码。</li>
<li>同时由于 Socket 的接收缓冲区已经有了数据，Recv 可以返回接收到的数据。</li>
</ul>
</li>
<li>内核接收网络数据全过程<ul>
<li>计算机收到了对端传送的数据</li>
<li>数据经由网卡传送到内存</li>
<li>然后网卡通过中断信号通知 CPU 有数据到达，CPU 执行中断程序<ul>
<li>此处的中断程序主要有两项功能，先将网络数据写入到对应 Socket 的接收缓冲区里面，再唤醒进程 A，重新将进程A放入工作队列中。</li>
</ul>
</li>
<li>以上是内核接收数据全过程，这里我们可能会思考两个问题：<ul>
<li>操作系统如何知道网络数据对应于哪个 Socket?</li>
<li>如何同时监视多个Socket的数据?</li>
</ul>
</li>
<li>第一个问题：因为一个Socket对应着一个端口号，而网络数据包中包含了IP和端口的信息，内核可以通过端口号找到对应的 Socket。</li>
<li>第二个问题：是多路复用的重中之重。</li>
</ul>
</li>
<li>同时监视多个Socket的简单方法<ul>
<li>服务端需要管理多个客户端连接，而Recv只能监视单个 Socket，这种矛盾下，人们开始寻找监视多个 Socket 的方法。Epoll 的要义就是高效地监视多个 Socket。</li>
<li>假如能够预先传入一个 Socket 列表，如果列表中的 Socket 都没有数据，挂起进程，直到有一个 Socket 收到数据，唤醒进程。这种方法很直接，也是 Select 的设计思想。</li>
</ul>
</li>
<li>select<ul>
<li>用法<ul>
<li>先准备一个数组 FDS，让 FDS 存放着所有需要监视的 Socket。</li>
<li>然后调用 Select，如果 FDS 中的所有 Socket 都没有数据，Select 会阻塞，直到有一个 Socket 接收到数据，Select 返回，唤醒进程。</li>
<li>用户可以遍历FDS，通过FD_ISSET判断具体哪个Socket收到数据，然后做出处理。 </li>
<li>总流程：Select 的实现思路很直接，假如程序同时监视如下图的 Sock1、Sock2 和 Sock3 三个 Socket，那么在调用Select之后，操作系统把进程A分别加入这三个Socket的等待队列中。当任何一个 Socket 收到数据后，中断程序将唤起进程。所谓唤起进程，就是将进程从所有的等待队列中移除，加入到工作队列里。 经由这些步骤，当进程 A 被唤醒后，它知道至少有一个 Socket 接收了数据。程序只需遍历一遍 Socket 列表，就可以得到就绪的 Socket。</li>
</ul>
</li>
<li>select缺点<ul>
<li>每次调用 Select都需要将进程加入到所有监视Socket的等待队列，每次唤醒都需要从每个队列中移除。这里涉及了两次遍历，而且每次都要将整个FDS列表传递给内核，有一定的开销。正是因为遍历操作开销大，出于效率的考量，才会规定 Select 的最大监视数量，默认只能监视1024个Socket。</li>
<li>进程被唤醒后，程序并不知道哪些 Socket 收到数据，还需要遍历一次。</li>
</ul>
</li>
</ul>
</li>
<li>Epoll<ul>
<li>设计思路<ul>
<li>措施一：功能分离<ul>
<li>Select 低效的原因之一是将“维护等待队列”和“阻塞进程”两个步骤合二为一。Epoll 拆分了功能</li>
<li>Epoll 将这两个操作分开，先用 epoll_ctl 维护等待队列，再调用 epoll_wait 阻塞进程。显而易见地，效率就能得到提升。</li>
</ul>
</li>
<li></li>
</ul>
</li>
<li>用法：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int s = socket(AF_INET, SOCK_STREAM, 0);    </span><br><span class="line">bind(s, ...) </span><br><span class="line">listen(s, ...) </span><br><span class="line"> </span><br><span class="line">int epfd = epoll_create(...); </span><br><span class="line">epoll_ctl(epfd, ...); //将所有需要监听的socket添加到epfd中 </span><br><span class="line"> </span><br><span class="line">while(1)&#123; </span><br><span class="line">    int n = epoll_wait(...) </span><br><span class="line">    for(接收到数据的socket)&#123; </span><br><span class="line">        //处理 </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>就绪列表<ul>
<li>Select 低效的另一个原因在于程序不知道哪些Socket收到数据，只能一个个遍历。如果内核维护一个“就绪列表”，引用收到数据的 Socket，就能避免遍历。<br>  <img src="https://img-blog.csdnimg.cn/20191025215514941.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FybWxpbnV4d3c=,size_16,color_FFFFFF,t_70" alt="image"></li>
<li>就绪列表示意图。如上图所示，计算机共有三个 Socket，收到数据的 Sock2 和 Sock3 被就绪列表 Rdlist 所引用。当进程被唤醒后，只要获取 Rdlist 的内容，就能够知道哪些 Socket 收到数据。</li>
</ul>
</li>
</ul>
</li>
<li>流程<ul>
<li>内核创建 eventpoll 对象<ul>
<li>eventpoll对象也是文件系统中的一员，和Socket一样，它也会有等待队列。（一个socket有一个等待队列）</li>
<li>创建一个代表该Epoll的eventpoll对象是必须的，因为内核要维护“就绪列表”等数据，“就绪列表”可以作为 eventpoll 的成员。</li>
</ul>
</li>
<li>维护监视列表<ul>
<li>创建 Epoll 对象后，可以用 epoll_ctl 添加或删除所要监听的 Socket。以添加 Socket 为例。</li>
<li>如果通过 epoll_ctl 添加 Sock1、Sock2 和 Sock3 的监视，内核会将 eventpoll 添加到这三个 Socket 的等待队列中。</li>
<li>当Socket收到数据后，中断程序会操作 eventpoll 对象，而不是直接操作进程。</li>
</ul>
</li>
<li>接收数据<ul>
<li>当 Socket 收到数据后，中断程序会给 eventpoll 的“就绪列表”添加 Socket 引用。</li>
<li>Sock2 和 Sock3 收到数据后，中断程序让 Rdlist 引用这两个 Socket。</li>
<li>eventpoll对象相当于Socket和进程之间的中介，Socket的数据接收并不直接影响进程，而是通过改变eventpoll的就绪列表来改变进程状态。</li>
<li>当程序执行到 epoll_wait 时，如果 Rdlist 已经引用了 Socket，那么 epoll_wait 直接返回，如果 Rdlist 为空，阻塞进程。</li>
</ul>
</li>
<li>阻塞和唤醒进程<ul>
<li>假设计算机中正在运行进程A和进程B，在某时刻进程A运行到了epoll_wait语句。</li>
<li>内核会将进程 A 放入 eventpoll 的等待队列中，阻塞进程。</li>
<li>当 Socket 接收到数据，中断程序一方面修改 Rdlist，另一方面唤醒 eventpoll 等待队列中的进程，进程 A 再次进入运行状态，Epoll 唤醒进程</li>
<li>因为Rdlist的存在，进程A可以知道哪些 Socket 发生了变化。</li>
</ul>
</li>
</ul>
</li>
<li>epoll的实现细节<br>  <img src="https://img-blog.csdnimg.cn/20191025220418729.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FybWxpbnV4d3c=,size_16,color_FFFFFF,t_70" alt="image"><ul>
<li>就绪列表的数据结构<ul>
<li>就绪列表引用着就绪的 Socket，所以它应能够快速的插入数据。程序可能随时调用 epoll_ctl 添加监视 Socket，也可能随时删除。当删除时，若该Socket已经存放在就绪列表中，它也应该被移除。所以就绪列表应是一种能够快速插入和删除的数据结构。</li>
</ul>
</li>
<li>索引结构<ul>
<li>既然 Epoll 将“维护监视队列”和“进程阻塞”分离，也意味着需要有个数据结构来保存监视的 Socket，至少要方便地添加和移除，还要便于搜索，以避免重复添加。</li>
<li>红黑树是一种自平衡二叉查找树**，搜索、插入和删除时间复杂度都是O(log(N))**，效率较好，Epoll 使用了红黑树作为索引结构(对应上图的 RBR)。</li>
<li>因为操作系统要兼顾多种功能，以及有更多需要保存的数据，<strong>Rdlist并非直接引用Socket，而是通过Epitem间接引用，红黑树的节点也是Epitem对象。</strong></li>
</ul>
</li>
</ul>
</li>
<li>总结<ul>
<li>Epoll在Select和Poll的基础上引入了eventpoll作为中间层，使用了先进的数据结构，是一种高效的多路复用技术。</li>
<li>以表格形式简单对比一下 Select、Poll 与 Epoll<br>  <img src="https://img-blog.csdnimg.cn/20191025220607592.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FybWxpbnV4d3c=,size_16,color_FFFFFF,t_70" alt="image"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>源码分析</p>
<ul>
<li>假设一个进程保持了10000条连接，那么如何发现哪条连接上有数据可读了、哪条连接可写了？<ul>
<li>采用循环遍历的方式来发现IO事件太低级了</li>
<li>IO多路复用机制更高效</li>
</ul>
</li>
<li>和epoll相关的函数是如下三个：<ul>
<li>epoll_create：创建一个epoll对象</li>
<li>epoll_ctl：向epoll对象中添加要管理的连接</li>
<li>epoll_wait：等待其管理的连接上的 IO 事件</li>
</ul>
</li>
<li>流程<br>  1）accept创建新socket<ul>
<li>我们直接从服务器端的accept讲起。当accept之后，进程会创建一个新的 socket出来，专门用于和对应的客户端通信，然后把它放到当前进程的打开文件列表中。 </li>
<li>其中一条连接的socket内核对象更为具体一点的结构图如下。<br>  <img src="https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwolcxS62c1ZRibFc0NUVCJ46bVib0GkOQyXSwBdrPVqrPpSnwbZpdsuiajVKypicmocdh5nYCSP3tAjGQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="image"></li>
<li>接收连接时socket内核对象的创建源码。accept的系统调用代码位于源文件net&#x2F;socket.c下<br>  1.1）初始化struct socket对象<ul>
<li>调用 sock_alloc 申请一个struct socket对象出来</li>
<li>把 listen 状态的 socket 对象上的协议操作函数集合 ops 赋值给新的 socket。（对于所有的 AF_INET 协议族下的 socket来说，它们的ops方法都是一样的，所以这里可以直接复制过来）</li>
<li>其中 inet_stream_ops 的定义如下  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//file: net/ipv4/af_inet.c</span><br><span class="line">const struct proto_ops inet_stream_ops = &#123;</span><br><span class="line">    ...</span><br><span class="line">    .accept        = inet_accept,</span><br><span class="line">    .listen        = inet_listen,</span><br><span class="line">    .sendmsg       = inet_sendmsg,</span><br><span class="line">    .recvmsg       = inet_recvmsg,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  1.2）为新socket对象申请file</li>
<li>socket对象中有一个重要的成员，file内核对象指针。在 accept方法里会调用sock_alloc_file来申请内存并初始化。然后将新 file 对象设置到 sock-&gt;file 上。</li>
<li>sock_alloc_file 的实现过程：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct file *sock_alloc_file(struct socket *sock, int flags, </span><br><span class="line">    const char *dname)</span><br><span class="line">&#123;</span><br><span class="line">    struct file *file;</span><br><span class="line">    file = alloc_file(&amp;path, FMODE_READ | FMODE_WRITE,</span><br><span class="line">            &amp;socket_file_ops);</span><br><span class="line">    ......</span><br><span class="line">    sock-&gt;file = file;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>sock_alloc_file又会接着调用到alloc_file。注意在alloc_file 方法中，把 socket_file_ops 函数集合一并赋到了新 file-&gt;f_op 里了。  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//file: fs/file_table.c</span><br><span class="line">struct file *alloc_file(struct path *path, fmode_t mode,</span><br><span class="line">        const struct file_operations *fop)</span><br><span class="line">&#123;</span><br><span class="line">    struct file *file;</span><br><span class="line">    file-&gt;f_op = fop;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>这里看到，在accept里创建的新 socket 里的 file-&gt;f_op-&gt;poll 函数指向的是 sock_poll。接下来我们会调用到它，后面我们再说。</li>
<li>其实 file 对象内部也有一个 socket 指针，指向 socket 对象。<br>  1.3）接收连接</li>
<li>在socket内核对象中除了file对象指针以外，有一个核心成员sock。</li>
<li>这个 struct sock数据结构非常大，是socket的核心内核对象。<br>  <strong>发送队列、接收队列、等待队列</strong>等核心数据结构都位于此。</li>
<li>sock-&gt;ops-&gt;accept 对应的方法是 inet_accept。它执行的时候会从握手队列里直接获取创建好的 sock。sock 对象的完整创建过程涉及到三次握手<br>  1.4）添加新文件到当前进程的打开文件列表中<br>  2）epoll_create</li>
</ul>
</li>
<li>在用户进程调用 epoll_create 时，内核会创建一个struct event poll的内核对象。并同样把它关联到当前进程的已打开文件列表中。</li>
<li>struct eventpoll 对象，更详细的结构如下<br>  <img src="https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwolcxS62c1ZRibFc0NUVCJ46RyK6lYFdDkVRH2xMBjFoeo0MKGzfMSGVFfbMuPtwAFt8w8FnQUIxeQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="image"></li>
<li>epoll_create 的源代码  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// file：fs/eventpoll.c</span><br><span class="line">SYSCALL_DEFINE1(epoll_create1, int, flags)</span><br><span class="line">&#123;</span><br><span class="line">    struct eventpoll *ep = NULL;</span><br><span class="line"></span><br><span class="line">    //创建一个 eventpoll 对象</span><br><span class="line">    error = ep_alloc(&amp;ep);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// file：fs/eventpoll.c</span><br><span class="line">struct eventpoll &#123;</span><br><span class="line"></span><br><span class="line">    //sys_epoll_wait用到的等待队列</span><br><span class="line">    wait_queue_head_t wq;</span><br><span class="line"></span><br><span class="line">    //接收就绪的描述符都会放到这里</span><br><span class="line">    struct list_head rdllist;</span><br><span class="line"></span><br><span class="line">    //每个epoll对象中都有一颗红黑树</span><br><span class="line">    struct rb_root rbr;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>wq： 等待队列链表。<strong>软中断数据就绪</strong>的时候会通过wq来找到阻塞在epoll对象上的用户进程。</li>
<li>rbr： 一棵红黑树。为了支持对海量连接的高效查找、插入和删除，eventpoll内部使用了一棵红黑树。通过这棵树来管理用户进程下添加进来的所有 socket 连接。</li>
<li>rdllist： 就绪的描述符的链表。当有的连接就绪的时候，内核会把就绪的连接放到 rdllist 链表里。这样应用进程只需要判断链表就能找出就绪进程，而不用去遍历整棵树。<br>  3）epoll_ctl 添加 socket（关键）</li>
<li>在使用 epoll_ctl 注册每一个 socket 的时候，内核会做如下三件事情<ul>
<li>分配一个红黑树节点对象epitem，</li>
<li>添加等待事件到socket的等待队列中，其回调函数是ep_poll_callback</li>
<li>将epitem插入到epoll对象的红黑树里</li>
</ul>
</li>
<li>通过 epoll_ctl 添加两个 socket 以后，这些内核数据结构最终在进程中的关系图大致如下：<br>  <img src="https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwolcxS62c1ZRibFc0NUVCJ46UzHy4WvRpicUaNuqIibhPJcyRiacqeDZx0MX9sqkibCsIJDMbujC6IqA8w/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="image"></li>
<li>socket 是如何添加到 epoll 对象里的，找到 epoll_ctl 的源码。  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">// file：fs/eventpoll.c</span><br><span class="line">SYSCALL_DEFINE4(epoll_ctl, int, epfd, int, op, int, fd,</span><br><span class="line">        struct epoll_event __user *, event)</span><br><span class="line">&#123;</span><br><span class="line">    struct eventpoll *ep;</span><br><span class="line">    struct file *file, *tfile;</span><br><span class="line"></span><br><span class="line">    //根据 epfd 找到 eventpoll 内核对象</span><br><span class="line">    file = fget(epfd);</span><br><span class="line">    ep = file-&gt;private_data;</span><br><span class="line"></span><br><span class="line">    //根据 socket 句柄号， 找到其 file 内核对象</span><br><span class="line">    tfile = fget(fd);</span><br><span class="line"></span><br><span class="line">    switch (op) &#123;</span><br><span class="line">    case EPOLL_CTL_ADD:</span><br><span class="line">        if (!epi) &#123;</span><br><span class="line">            epds.events |= POLLERR | POLLHUP;</span><br><span class="line">            error = ep_insert(ep, &amp;epds, tfile, fd);</span><br><span class="line">        &#125; else</span><br><span class="line">            error = -EEXIST;</span><br><span class="line">        clear_tfile_check_list();</span><br><span class="line">        break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//file: fs/eventpoll.c</span><br><span class="line">static int ep_insert(struct eventpoll *ep, </span><br><span class="line">                struct epoll_event *event,</span><br><span class="line">                struct file *tfile, int fd)</span><br><span class="line">&#123;</span><br><span class="line">    //3.1 分配并初始化 epitem</span><br><span class="line">    //分配一个epi对象</span><br><span class="line">    struct epitem *epi;</span><br><span class="line">    if (!(epi = kmem_cache_alloc(epi_cache, GFP_KERNEL)))</span><br><span class="line">        return -ENOMEM;</span><br><span class="line"></span><br><span class="line">    //对分配的epi进行初始化</span><br><span class="line">    //epi-&gt;ffd中存了句柄号和struct file对象地址</span><br><span class="line">    INIT_LIST_HEAD(&amp;epi-&gt;pwqlist);</span><br><span class="line">    epi-&gt;ep = ep;</span><br><span class="line">    ep_set_ffd(&amp;epi-&gt;ffd, tfile, fd);</span><br><span class="line"></span><br><span class="line">    //3.2 设置 socket 等待队列</span><br><span class="line">    //定义并初始化 ep_pqueue 对象</span><br><span class="line">    struct ep_pqueue epq;</span><br><span class="line">    epq.epi = epi;</span><br><span class="line">    init_poll_funcptr(&amp;epq.pt, ep_ptable_queue_proc);</span><br><span class="line"></span><br><span class="line">    //调用 ep_ptable_queue_proc 注册回调函数 </span><br><span class="line">    //实际注入的函数为 ep_poll_callback</span><br><span class="line">    revents = ep_item_poll(epi, &amp;epq.pt);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    //3.3 将epi插入到 eventpoll 对象中的红黑树中</span><br><span class="line">    ep_rbtree_insert(ep, epi);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  3.1） 分配并初始化epitem<ul>
<li>对于每一个socket，调用epoll_ctl的时候，都会为之分配一个epitem。该结构的主要数据如下：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//file: fs/eventpoll.c</span><br><span class="line">struct epitem &#123;</span><br><span class="line"></span><br><span class="line">    //红黑树节点</span><br><span class="line">    struct rb_node rbn;</span><br><span class="line"></span><br><span class="line">    //socket文件描述符信息</span><br><span class="line">    struct epoll_filefd ffd;</span><br><span class="line"></span><br><span class="line">    //所归属的 eventpoll 对象</span><br><span class="line">    struct eventpoll *ep;</span><br><span class="line"></span><br><span class="line">    //等待队列</span><br><span class="line">    struct list_head pwqlist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>对epitem进行了一些初始化，首先在epi-&gt;ep &#x3D; ep这行代码中将其 ep 指针指向 eventpoll 对象。另外用要添加的 socket 的 file、fd 来填充 epitem-&gt;ffd。<br>  <img src="https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwolcxS62c1ZRibFc0NUVCJ46Lv6akrqjicm78bMNVmo3SiaCPOiaYokVwHGia82tDn4Xaw1wHIXVkB7yBA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="image"></li>
<li>其中使用到的 ep_set_ffd 函数如下。  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static inline void ep_set_ffd(struct epoll_filefd *ffd,</span><br><span class="line">                        struct file *file, int fd)</span><br><span class="line">&#123;</span><br><span class="line">    ffd-&gt;file = file;</span><br><span class="line">    ffd-&gt;fd = fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  3.2）设置 socket 等待队列</li>
<li>在创建epitem并初始化之后，ep_insert中第二件事情就是设置socket对象上的等待任务队列。并把函数 fs&#x2F;eventpoll.c 文件下的 ep_poll_callback 设置为数据就绪时候的回调函数。<br>  <img src="https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwolcxS62c1ZRibFc0NUVCJ46EJickksDhHBUDOsZw10M4PARys1wiaBeK3wDx2frGnnxFt02Kv2tGiaDQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="image"></li>
<li>在 sock_poll_wait 的第二个参数传参前，先调用了 sk_sleep 函数。在这个函数里它获取了 sock 对象下的等待队列列表头 wait_queue_head_t，待会等待队列项就插入这里。这里稍微注意下，是 socket 的等待队列，不是 epoll 对象的。来看 sk_sleep 源码：</li>
<li>在 ep_ptable_queue_proc 函数中，新建了一个等待队列项，并注册其回调函数为 ep_poll_callback 函数。然后再将这个等待项添加到 socket 的等待队列中。<br>  3.3）分配完 epitem 对象后，紧接着并把它插入到红黑树中。一个插入了一些 socket 描述符的 epoll 里的红黑树的示意图如下：<br>  <img src="https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwolcxS62c1ZRibFc0NUVCJ46jP61gF0DeUkU7SFic0yMK3cjpcbQqt3j6t0lEKSZUrvXpRYoN7dacVw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="image"></li>
<li>这里我们再聊聊为啥要用红黑树，很多人说是因为效率高。其实我觉得这个解释不够全面，要说查找效率树哪能比的上 HASHTABLE。我个人认为觉得更为合理的一个解释是为了让 epoll 在查找效率、插入效率、内存开销等等多个方面比较均衡，最后发现最适合这个需求的数据结构是红黑树。<br>  4）epoll_wait 等待接收</li>
<li>epoll_wait 做的事情不复杂，当它被调用时它观察 eventpoll-&gt;rdllist 链表里有没有数据即可。有数据就返回，没有数据就创建一个等待队列项，将其添加到 eventpoll 的等待队列上，然后把自己阻塞掉就完事。<br>  <img src="https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwolcxS62c1ZRibFc0NUVCJ46DTCVLYKALXJpjB3Glp2bjPzVS3s8dASJeZ2wUfo0rlM2O7ic8y7Eib2g/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="image"><br>  注意：epoll_ctl 添加 socket 时也创建了等待队列项。不同的是这里的等待队列项是挂在 epoll 对象上的，而前者是挂在 socket 对象上的。  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//file: fs/eventpoll.c</span><br><span class="line">SYSCALL_DEFINE4(epoll_wait, int, epfd, struct epoll_event __user *, events,</span><br><span class="line">        int, maxevents, int, timeout)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    error = ep_poll(ep, events, maxevents, timeout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int ep_poll(struct eventpoll *ep, struct epoll_event __user *events,</span><br><span class="line">             int maxevents, long timeout)</span><br><span class="line">&#123;</span><br><span class="line">    wait_queue_t wait;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">fetch_events:</span><br><span class="line">    //4.1 判断就绪队列上有没有事件就绪</span><br><span class="line">    if (!ep_events_available(ep)) &#123;</span><br><span class="line"></span><br><span class="line">        //4.2 定义等待事件并关联当前进程</span><br><span class="line">        init_waitqueue_entry(&amp;wait, current);</span><br><span class="line"></span><br><span class="line">        //4.3 把新 waitqueue 添加到 epoll-&gt;wq 链表里</span><br><span class="line">        __add_wait_queue_exclusive(&amp;ep-&gt;wq, &amp;wait);</span><br><span class="line">    </span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            ...</span><br><span class="line">            //4.4 让出CPU 主动进入睡眠状态</span><br><span class="line">            if (!schedule_hrtimeout_range(to, slack, HRTIMER_MODE_ABS))</span><br><span class="line">                timed_out = 1;</span><br><span class="line">            ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  4.1）判断就绪队列上有没有事件就绪</li>
<li>首先调用ep_events_available来判断就绪链表中是否有可处理的事件。<br>  4.2）定义等待事件并关联当前进程</li>
<li>假设确实没有就绪的连接，那接着会进入 init_waitqueue_entry 中定义等待任务，并把 current （当前进程）添加到 waitqueue 上。</li>
<li>是的，当没有IO事件的时候，epoll也是会阻塞掉当前进程。这个是合理的，因为没有事情可做了占着 CPU 也没啥意义。网上的很多文章有个很不好的习惯，讨论阻塞、非阻塞等概念的时候都不说主语。这会导致你看的云里雾里。拿 epoll 来说，epoll 本身是阻塞的，但一般会把 socket 设置成非阻塞。只有说了主语，这些概念才有意义。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>epoll_wait</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys / epoll.h&gt;</span><br><span class="line">int epoll_wait（int epfd，struct epoll_event * events， int maxevents，int timeout）;</span><br></pre></td></tr></table></figure>
<ul>
<li>功能：等待epoll文件描述符上的I &#x2F; O事件。</li>
<li>参数：<ul>
<li>timeout： timeout参数指定epoll_wait（）将阻止的最小毫秒数。 （此间隔将四舍五入为系统时钟的粒度，并且内核调度延迟意味着阻塞间隔可能会少量溢出。）指定超时值为-1会导致epoll_wait（）无限期阻塞，而指定的超时时间等于零导致epoll_wait（）立即返回，即使没有可用事件。<h2 id="LINUX网络编程"><a href="#LINUX网络编程" class="headerlink" title="LINUX网络编程"></a>LINUX网络编程</h2><h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3></li>
</ul>
</li>
</ul>
</li>
<li><p>getsockopt</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int getsockopt(int socket, int level, int option_name,</span><br><span class="line">            void *restrict option_value, socklen_t *restrict option_len);</span><br></pre></td></tr></table></figure>
<ul>
<li>功能：获取一个套接字的选项</li>
<li>参数：<ul>
<li>socket：文件描述符</li>
<li>level：协议层次<ul>
<li>SOL_SOCKET 套接字层次</li>
<li>IPPROTO_IP ip层次</li>
<li>IPPROTO_TCP TCP层次</li>
</ul>
</li>
<li>option_name：选项的名称（套接字层次）<ul>
<li>SO_BROADCAST 是否允许发送广播信息</li>
<li>SO_REUSEADDR 是否允许重复使用本地地址</li>
<li>SO_SNDBUF 获取发送缓冲区长度</li>
<li>SO_RCVBUF 获取接收缓冲区长度</li>
<li>SO_RCVTIMEO 获取接收超时时间</li>
<li>SO_SNDTIMEO 获取发送超时时间</li>
</ul>
</li>
<li>option_value：获取到的选项的值</li>
<li>option_len：value的长度</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="文件句柄操作"><a href="#文件句柄操作" class="headerlink" title="文件句柄操作"></a>文件句柄操作</h3><ul>
<li>O_NONBLOCK和O_NDELAY所产生的结果都是使I&#x2F;O变成非阻塞模式(non-blocking)，在读取不到数据或是写入缓冲区已满会马上return，而不会阻塞等待。<ul>
<li>在读操作时，如果读不到数据，O_NDELAY会使I&#x2F;O函数马上返回0，但这又衍生出一个问题，因为读取到文件末尾(EOF)时返回的也是0，这样无法区分是哪种情况。因此，O_NONBLOCK就产生出来，它在读取不到数据时会回传-1，并且设置errno为EAGAIN。</li>
</ul>
</li>
</ul>
<h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><ul>
<li>EAGIN<ul>
<li>这个错误经常出现在当应用程序进行一些非阻塞(non-blocking)操作(对文件或socket)的时候。</li>
<li>例如，以O_NONBLOCK的标志打开文件&#x2F;socket&#x2F;FIFO，如果你连续做read操作而没有数据可读。此时程序不会阻塞起来等待数据准备就绪返回，read函数会返回一个错误EAGAIN，提示你的应用程序现在没有数据可读请稍后再试</li>
<li>又例如，当一个系统调用(比如fork)因为没有足够的资源(比如虚拟内存)而执行失败，返回EAGAIN提示其再调用一次(也许下次就能成功)。</li>
</ul>
</li>
<li>EINTR<ul>
<li>read（）如果读到数据为0，那么就表示文件结束了，如果在读的过程中遇到了中断那么会返回-1，同时置errno为EINTR。</li>
</ul>
</li>
<li>ETIMEDOUT<ul>
<li>连接超时</li>
</ul>
</li>
</ul>
<h2 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a>序列化与反序列化</h2><ul>
<li><p>序列化的原本意图是希望对一个对象作一下“变换”，变成字节序列，这样一来<strong>方便持久化存储到磁盘</strong>，避免程序运行结束后对象就从内存里消失，另外变换成字节序列也更便于网络运输和传播，所以概念上很好理解：</p>
</li>
<li><p>序列化：把对象转换为字节序列。</p>
</li>
<li><p>反序列化：把字节序列恢复为原先的对象。</p>
</li>
<li><p>对象如何序列化？</p>
<ul>
<li>对象的持久化和反持久化需要靠程序员在代码里手动显式地进行序列化和反序列化还原的动作。</li>
</ul>
</li>
<li><p>序列化</p>
<ul>
<li>在TCP的连接上，它传输数据的基本形式就是二进制流，也就是一段一段的1和0</li>
<li>在一般编程语言或者网络框架提供的API中，传输数据的基本形式是字节，也就是Byte。一个字节就是8个二进制位，8个Bit。<ul>
<li>二进制流和字节流本质上是一样的。对于我们编写的程序来说，它需要通过网络传输的数据是结构化的数据，比如，一条命令、一段文本或者一条消息。对应代码中，这些结构化的数据都可以用一个类或者一个结构体来表示。</li>
</ul>
</li>
<li>序列化的用途除了用于在网络上传输数据以外</li>
<li>将结构化数据保存在文件中（将对象存储于硬盘上），因为文件内保存数据的形式也是二进制序列。</li>
<li>问题：在内存里存放的任何数据，它最基础的存储单元也是二进制比特，也就是说，我们应用程序操作的对象，它在内存中也是使用二进制存储的，既然都是二进制，为什么不能直接把内存中，对象对应的二进制数据直接通过网络发送出去，或者保存在文件中呢？为什么还需要序列化和反序列化呢？<ul>
<li><strong>内存里存的东西，不通用，不同系统，不同语言的组织可能都是不一样的，而且还存在很多引用，指针，并不是直接数据块</strong>。内存中的对象数据应该具有语言独特性，例如表达相同业务的User对象(id&#x2F;name&#x2F;age字段),Java和PHP在内存中的数据格式应该不一样的，如果直接用内存中的数据，可能会造成语言不通。只要对序列化的数据格式进行了协商，任何2个语言直接都可以进行序列化传输、接收。</li>
<li>一个数据结构，里面存储的数据是经过非常多其他数据通过非常复杂的算法生成的，因为数据量非常大，因此生成该数据结构所用数据的时间可能要非常久，生成该数据结构后又要用作其他的计算，那么你在调试阶段，每次执行个程序，就光生成数据结构就要花上这么长的时间。假设你确定生成数据结构的算法不会变或不常变，<strong>那么就能够通过序列化技术生成数据结构数据存储到磁盘上，下次又一次执行程序时仅仅须要从磁盘上读取该对象数据就可以，所花费时间也就读一个文件的时间。</strong></li>
<li>虽然都是二进制的数据，但是序列化的二进制数据是通过一定的协议将数据字段进行拼接。第一个优势是：不同的语言都可以遵循这种协议进行解析，实现了跨语言。第二个优势是：这种数据可以直接持久化到磁盘，从磁盘读取后也可以通过这个协议解析出来。</li>
</ul>
</li>
<li>定义：<ul>
<li>要想使用网络框架的API来传输结构化的数据，必须得先实现结构化的数据与字节流之间的双向转换。这种将结构化数据转换成字节流的过程，称为序列化，反过来转换，就是反序列化。</li>
<li>简单来说，序列化就是<strong>将对象实例的状态转换为可保持或传输的格式的过程</strong>。与序列化相对的是反序列化，它依据流重构对象。这两个过程结合起来，能够轻松地存储和数据传输。</li>
<li>比如，能够序列化一个对象，然后使用HTTP 通过 Internet 在client和server之间传输该对象。</li>
</ul>
</li>
<li>序列化评价指标<ul>
<li>可读性<ul>
<li>序列化后的数据最好是易于人类阅读的</li>
</ul>
</li>
<li>实现复杂度<ul>
<li>实现的复杂度是否足够低</li>
</ul>
</li>
<li>性能<ul>
<li>序列化和反序列化的速度越快越好</li>
</ul>
</li>
<li>信息密度<ul>
<li>序列化后的信息密度越大越好，也就是说，同样的一个结构化数据，序列化之后占用的存储空间越小越好</li>
</ul>
</li>
</ul>
</li>
<li></li>
</ul>
</li>
</ul>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="http://example.com/2022/05/16/C++%20%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/" title="C++ 高性能服务器框架日志" target="_blank" rel="external">http://example.com/2022/05/16/C++ 高性能服务器框架开发日志/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://github.com/Miracle-Pig" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.jpg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://github.com/Miracle-Pig" target="_blank"><span class="text-dark">Miracle-Pig</span><small class="ml-1x">Web Developer &amp; Designer</small></a></h3>
        <div>个人简介。</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    
  <section id="comments">
  	
      <div id="vcomments"></div>
    
  </section>


  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2022/05/16/C&C++%20Notebool/" title="C&amp;C++ Notebook"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;Newer</span></a>
    </li>
    
    
    
    <li class="toggle-toc">
      <a class="toggle-btn " data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="Catalogue" role="button">    <span>[&nbsp;</span><span>Catalogue</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  <!-- Button trigger modal -->
  <button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>$</span></button>
  <!-- <div class="wave-icon wave-icon-danger btn-donate" data-toggle="modal" data-target="#donateModal">
    <div class="wave-circle"><span class="icon"><i class="icon icon-bill"></i></span></div>
  </div> -->
  
  
  <div class="bar-right">
    
  </div>
  </div>
</nav>
  
<!-- Modal -->
<div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog">
  <div class="modal-dialog" role="document">
    <div class="modal-content donate">
      <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
      <div class="modal-body">
        <div class="donate-box">
          <div class="donate-head">
            <p>Maybe you could buy me a cup of coffee.</p>
          </div>
          <div class="tab-content">
            <div role="tabpanel" class="tab-pane fade active in" id="alipay">
              <div class="donate-payimg">
                <img src="/images/donate/alipayimg.png" alt="Scan Qrcode" title="Scan" />
              </div>
              <p class="text-muted mv">Scan this qrcode</p>
              <p class="text-grey">Open alipay app scan this qrcode, buy me a coffee!</p>
            </div>
            <div role="tabpanel" class="tab-pane fade" id="wechatpay">
              <div class="donate-payimg">
                <img src="/images/donate/wechatpayimg.png" alt="Scan Qrcode" title="Scan" />
              </div>
              <p class="text-muted mv">Scan this qrcode</p>
              <p class="text-grey">Open wechat app scan this qrcode, buy me a coffee!</p>
            </div>
          </div>
          <div class="donate-footer">
            <ul class="nav nav-tabs nav-justified" role="tablist">
              <li role="presentation" class="active">
                <a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> alipay</a>
              </li>
              <li role="presentation" class="">
                <a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> wechat payment</a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>



</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/Miracle-Pig" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
        	Theme by <a href="https://github.com/cofess" target="_blank"> cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.
        </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: 'Posts',
            PAGES: 'Pages',
            CATEGORIES: 'Categories',
            TAGS: 'Tags',
            UNTITLED: '(Untitled)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>






   




   
    
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/valine"></script>
  <script type="text/javascript">
  var GUEST = ['nick', 'mail', 'link'];
  var meta = 'nick,mail,link';
  meta = meta.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#vcomments',
    verify: false,
    notify: false,
    appId: '',
    appKey: '',
    placeholder: 'Just go go',
    avatar: 'mm',
    meta: meta,
    pageSize: '10' || 10,
    visitor: false
  });
  </script>

     







</body>
</html>